const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./loader-hjgM5tDJ.js","./index-C_bK48d2.js","./index-DxLSJ8yk.css","./quat-BPAPKRxq.js","./quatf64-aQ5IuZRd.js","./BufferView-CruTDoyp.js","./resourceUtils-C9a876P6.js"])))=>i.map(i=>d[i]);
import{nb as ue,nc as ce,kT as G,kh as K,bF as ee,ls as me,a7 as fe,a6 as de,a as pe,nd as te,b4 as N,iz as re,mB as L,aF as he,_ as ge,ne as H,nf as xe,j1 as ye,j2 as W,j3 as be,b8 as we,b9 as Te,gu as Q,fN as ve,ng as J,fO as $e,bE as Me,gN as Re,b3 as q,gl as Ae}from"./index-C_bK48d2.js";import{a as Se}from"./devEnvironmentUtils-CnNDiFMM.js";import{m as se,n as j}from"./OutputColorHighlightOLID.glsl-sxs6Kjna.js";import{I as ne,z as Be,H as Ie,U as oe,q as Pe,G as Ee}from"./BufferView-CruTDoyp.js";import{r as Fe,n as Oe,d as X,l as Y}from"./vec3-DaPyUuf5.js";import{o as Ce,d as Z}from"./vec4-BQsyhewI.js";import{l as Ue,o as _e,n as je}from"./indexUtils-BOKGJzDE.js";import{t as k}from"./resourceUtils-C9a876P6.js";import{u as ke}from"./memoryEstimations-w0EAmzVg.js";import{t as Le}from"./NestedMap-DI2--xdt.js";import{o as Ve}from"./Indices-BnCWM-r-.js";import{r as ze}from"./image-CVbVCSUp.js";import{t as C}from"./orientedBoundingBox-QSEKbinM.js";import{M as ae}from"./ManagedTexture-B9Ayb5dV.js";import{y as V,s as De,t as Ge,n as He,o as qe}from"./DefaultMaterial-B2uHExbq.js";function _(r){if(r==null)return null;const t=r.offset!=null?r.offset:ue,s=r.rotation!=null?r.rotation:0,n=r.scale!=null?r.scale:ce,i=G(1,0,0,0,1,0,t[0],t[1],1),l=G(Math.cos(s),-Math.sin(s),0,Math.sin(s),Math.cos(s),0,0,0,1),o=G(n[0],0,0,0,n[1],0,0,0,1),a=ee();return K(a,l,o),K(a,i,a),a}class Ke{constructor(){this.geometries=new Array,this.materials=new Array,this.textures=new Array}}class Ne{constructor(t,s,n){this.name=t,this.lodThreshold=s,this.pivotOffset=n,this.stageResources=new Ke,this.numberOfVertices=0}}const I=()=>he.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class We{constructor(t,s,n){this.resource=t,this.textures=s,this.usedMemory=n}}async function Qe(r,t){const s=await Je(r,t),n=await tt(s.textureDefinitions??{},t);let i=0;for(const l in n)if(n.hasOwnProperty(l)){const o=n[l];i+=o!=null&&o.image?o.image.width*o.image.height*4:0}return new We(s,n,i+ke(s))}async function Je(r,t){const s=await me(fe(r,t));if(s.ok)return s.value.data;de(s.error),Xe(s.error)}function Xe(r){throw new pe("",`Request for object resource failed: ${r}`)}function Ye(r){const t=r.params,s=t.topology;let n=!0;switch(t.vertexAttributes||(I().warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const l=t.faces;if(l){if(t.vertexAttributes)for(const o in t.vertexAttributes){const a=l[o];a!=null&&a.values?(a.valueType!=null&&a.valueType!=="UInt32"&&(I().warn(`Unsupported indexed geometry indices type '${a.valueType}', only UInt32 is currently supported`),n=!1),a.valuesPerElement!=null&&a.valuesPerElement!==1&&(I().warn(`Unsupported indexed geometry values per element '${a.valuesPerElement}', only 1 is currently supported`),n=!1)):(I().warn(`Indexed geometry does not specify face indices for '${o}' attribute`),n=!1)}}else I().warn("Indexed geometries must specify faces"),n=!1;break}default:I().warn(`Unsupported topology '${s}'`),n=!1}r.params.material||(I().warn("Geometry requires material"),n=!1);const i=r.params.vertexAttributes;for(const l in i)i[l].values||(I().warn("Geometries with externally defined attributes are not yet supported"),n=!1);return n}function Ze(r,t){var g,f;const s=new Array,n=new Array,i=new Array,l=new Le,o=r.resource,a=te.parse(o.version||"1.0","wosr");st.validate(a);const c=o.model.name,e=o.model.geometries,u=o.materialDefinitions??{},m=r.textures;let w=0;const T=new Map;for(let b=0;b<e.length;b++){const d=e[b];if(!Ye(d))continue;const M=rt(d),x=d.params.vertexAttributes,B=[],v=p=>{if(d.params.topology==="PerAttributeArray")return null;const $=d.params.faces;for(const h in $)if(h===p)return $[h].values;return null},R=x.position,E=R.values.length/R.valuesPerElement;for(const p in x){const $=x[p],h=$.values,D=v(p)??Ve(E);B.push([p,new C(h,D,$.valuesPerElement,!0)])}const y=M.texture,A=m&&m[y];if(A&&!T.has(y)){const{image:p,parameters:$}=A,h=new ae(p,$);n.push(h),T.set(y,h)}const U=T.get(y),P=U?U.id:void 0,F=M.material;let S=l.get(F,y);if(S==null){const p=u[F.slice(F.lastIndexOf("/")+1)].params;p.transparency===1&&(p.transparency=0);const $=A?ie(A.alphaChannelUsage):void 0,h={ambient:N(p.diffuse),diffuse:N(p.diffuse),opacity:1-(p.transparency||0),textureAlphaMode:$,textureAlphaCutoff:.33,textureId:P,doubleSided:!0,cullFace:0,colorMixMode:p.externalColorMixMode||"tint",textureAlphaPremultiplied:(A==null?void 0:A.parameters.preMultiplyAlpha)??!1};t!=null&&t.materialParameters&&Object.assign(h,t.materialParameters),S=new V(h,t),l.set(F,y,S)}i.push(S);const z=new se(S,B);w+=((f=(g=B.find(p=>p[0]==="position"))==null?void 0:g[1])==null?void 0:f.indices.length)??0,s.push(z)}return{engineResources:[{name:c,stageResources:{textures:n,materials:i,geometries:s},pivotOffset:o.model.pivotOffset,numberOfVertices:w,lodThreshold:null}],referenceBoundingBox:et(s)}}function et(r){const t=re();return r.forEach(s=>{const n=s.boundingInfo;n!=null&&(L(t,n.bbMin),L(t,n.bbMax))}),t}async function tt(r,t){const s=new Array;for(const l in r){const o=r[l],a=o.images[0].data;if(!a){I().warn("Externally referenced texture data is not yet supported");continue}const c=o.encoding+";base64,"+a,e="/textureDefinitions/"+l,u=o.channels==="rgba"?o.alphaChannelUsage||"transparency":"none",m={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:ie(u)!==1},w=t!=null&&t.disableTextures?Promise.resolve(null):ze(c,t);s.push(w.then(T=>({refId:e,image:T,parameters:m,alphaChannelUsage:u})))}const n=await Promise.all(s),i={};for(const l of n)i[l.refId]=l;return i}function ie(r){switch(r){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function rt(r){const t=r.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const st=new te(1,2,"wosr");async function nt(r,t){const s=le(Se(r));if(s.fileType==="wosr"){const o=await(t.cache?t.cache.loadWOSR(s.url,t):Qe(s.url,t)),{engineResources:a,referenceBoundingBox:c}=Ze(o,t);return{lods:a,referenceBoundingBox:c,isEsriSymbolResource:!1,isWosr:!0}}let n;if(t.cache)n=await t.cache.loadGLTF(s.url,t,!!t.usePBR);else{const{loadGLTF:o}=await ge(()=>import("./loader-hjgM5tDJ.js"),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url);n=await o(new Ue,s.url,t,t.usePBR)}const{engineResources:i,referenceBoundingBox:l}=ot(n,t,s.specifiedLodIndex);return{lods:i,referenceBoundingBox:l,isEsriSymbolResource:n.meta.isEsriSymbolResource,isWosr:!1}}function le(r){const t=r.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return t?{fileType:"gltf",url:t[1],specifiedLodIndex:t[4]!=null?Number(t[4]):null}:r.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:r,specifiedLodIndex:null}:{fileType:"unknown",url:r,specifiedLodIndex:null}}function ot(r,t,s){var f;const n=r.model,i=r.meta,l=(f=n.meta)==null?void 0:f.ESRI_proxyEllipsoid,o=i.isEsriSymbolResource&&l!=null&&i.ESRI_webstyle==="EsriRealisticTreesStyle";o&&!r.customMeta.esriTreeRendering&&(r.customMeta.esriTreeRendering=!0,ut(r,l));const a=!!t.usePBR,c=i.isEsriSymbolResource?{usePBR:a,isSchematic:!1,treeRendering:o,mrrFactors:De}:{usePBR:a,isSchematic:!1,treeRendering:!1,mrrFactors:Ge},e={...t.materialParameters,treeRendering:o},u=new Array,m=new Map,w=new Map,T=n.lods.length,g=re();return n.lods.forEach((b,d)=>{const M=t.skipHighLods===!0&&(T>1&&d===0||T>3&&d===1)||t.skipHighLods===!1&&s!=null&&d!==s;if(M&&d!==0)return;const x=new Ne(b.name,b.lodThreshold,[0,0,0]);b.parts.forEach(B=>{const v=M?new V({},t):at(n,B,x,c,e,m,w,t,o),{geometry:R,vertexCount:E}=it(B,v??new V({},t)),y=R.boundingInfo;y!=null&&d===0&&(L(g,y.bbMin),L(g,y.bbMax)),v!=null&&(x.stageResources.geometries.push(R),x.numberOfVertices+=E)}),M||u.push(x)}),{engineResources:u,referenceBoundingBox:g}}function at(r,t,s,n,i,l,o,a,c){var x,B;const e=r.materials.get(t.material);if(e==null)return null;const{normal:u,color:m,texCoord0:w,tangent:T}=t.attributes,g=t.material+(u?"_normal":"")+(m?"_color":"")+(w?"_texCoord0":"")+(T?"_tangent":""),f=t.attributes.texCoord0!=null,b=t.attributes.normal!=null,d=lt(e.alphaMode);if(!l.has(g)){if(f){const P=(S,z=!1,p=!1)=>{if(S!=null&&!o.has(S)){const $=r.textures.get(S);if($){const h=$.data,D=z&&!k(h)?a.compressionOptions:void 0;o.set(S,new ae(k(h)?h.data:h,{...$.parameters,preMultiplyAlpha:!k(h)&&p,encoding:k(h)?h.encoding:void 0,compressionOptions:D}))}}},F=d!==1&&!c;P(e.colorTexture,F,d!==1),P(e.normalTexture),P(e.occlusionTexture,!0),P(e.emissiveTexture),P(e.metallicRoughnessTexture,!0)}const v=H(e.color[0]),R=H(e.color[1]),E=H(e.color[2]),y=e.colorTexture!=null&&f?o.get(e.colorTexture):null,A=He(e),U=((x=e.normalTextureTransform)==null?void 0:x.scale)!=null?(B=e.normalTextureTransform)==null?void 0:B.scale:xe;l.set(g,new V({...n,customDepthTest:1,textureAlphaMode:d,textureAlphaCutoff:e.alphaCutoff,diffuse:[v,R,E],ambient:[v,R,E],opacity:e.alphaMode==="OPAQUE"?1:e.opacity,doubleSided:e.doubleSided,doubleSidedType:"winding-order",cullFace:e.doubleSided?0:2,hasVertexColors:!!t.attributes.color,hasVertexTangents:!!t.attributes.tangent,normalType:b?0:2,castShadows:!0,receiveShadows:e.receiveShadows,receiveAmbientOcclusion:e.receiveAmbientOcclusion,textureId:y!=null?y.id:void 0,colorMixMode:e.colorMixMode,normalTextureId:e.normalTexture!=null&&f?o.get(e.normalTexture).id:void 0,textureAlphaPremultiplied:y!=null&&!!y.parameters.preMultiplyAlpha,occlusionTextureId:e.occlusionTexture!=null&&f?o.get(e.occlusionTexture).id:void 0,emissiveTextureId:e.emissiveTexture!=null&&f?o.get(e.emissiveTexture).id:void 0,metallicRoughnessTextureId:e.metallicRoughnessTexture!=null&&f?o.get(e.metallicRoughnessTexture).id:void 0,emissiveBaseColor:[e.emissiveFactor[0],e.emissiveFactor[1],e.emissiveFactor[2]],emissiveStrengthKHR:e.emissiveStrengthKHR!=null?e.emissiveStrengthKHR:1,emissiveStrengthFromSymbol:i.emissiveStrengthFromSymbol!=null?i.emissiveStrengthFromSymbol:void 0,mrrFactors:A?qe:[e.metallicFactor,e.roughnessFactor,n.mrrFactors[2]],isSchematic:A,colorTextureTransformMatrix:_(e.colorTextureTransform),normalTextureTransformMatrix:_(e.normalTextureTransform),scale:[U[0],U[1]],occlusionTextureTransformMatrix:_(e.occlusionTextureTransform),emissiveTextureTransformMatrix:_(e.emissiveTextureTransform),metallicRoughnessTextureTransformMatrix:_(e.metallicRoughnessTextureTransform),...i},a))}const M=l.get(g);if(s.stageResources.materials.push(M),f){const v=R=>{R!=null&&s.stageResources.textures.push(o.get(R))};v(e.colorTexture),v(e.normalTexture),v(e.occlusionTexture),v(e.emissiveTexture),v(e.metallicRoughnessTexture)}return M}function it(r,t){const s=r.attributes.position.count,n=_e(r.indices||s,r.primitiveType),i=j(3*s),{typedBuffer:l,typedBufferStride:o}=r.attributes.position;Fe(i,l,r.transform,3,o);const a=[["position",new C(i,n,3,!0)]];if(r.attributes.normal!=null){const e=j(3*s),{typedBuffer:u,typedBufferStride:m}=r.attributes.normal;ye(O,r.transform),Oe(e,u,O,3,m),W(O)&&X(e,e),a.push(["normal",new C(e,n,3,!0)])}if(r.attributes.tangent!=null){const e=j(4*s),{typedBuffer:u,typedBufferStride:m}=r.attributes.tangent;be(O,r.transform),Ce(e,u,O,4,m),W(O)&&X(e,e,4),a.push(["tangent",new C(e,n,4,!0)])}if(r.attributes.texCoord0!=null){const e=j(2*s),{typedBuffer:u,typedBufferStride:m}=r.attributes.texCoord0;je(e,u,2,m),a.push(["uv0",new C(e,n,2,!0)])}const c=r.attributes.color;if(c!=null){const e=new Uint8Array(4*s);c.elementCount===4?c instanceof ne?Z(e,c,1,255):(c instanceof Be||c instanceof Ie)&&Z(e,c,1/255,255):(e.fill(255),c instanceof oe?Y(e,c.typedBuffer,1,255,4,c.typedBufferStride):(r.attributes.color instanceof Pe||r.attributes.color instanceof Ee)&&Y(e,c.typedBuffer,1/255,255,4,r.attributes.color.typedBufferStride)),a.push(["color",new C(e,n,4,!0)])}return{geometry:new se(t,a),vertexCount:s}}const O=ee();function lt(r){switch(r){case"BLEND":return 0;case"MASK":return 2;case"OPAQUE":case null:case void 0:return 1}}function ut(r,t){for(let s=0;s<r.model.lods.length;++s){const n=r.model.lods[s];for(const i of n.parts){const l=i.attributes.normal;if(l==null)return;const o=i.attributes.position,a=o.count,c=q(),e=q(),u=q(),m=new Float32Array(4*a),w=new Float32Array(3*a),T=we(Te(),i.transform);let g=0,f=0;for(let b=0;b<a;b++){o.getVec(b,e),l.getVec(b,c),Q(e,e,i.transform),ve(u,e,t.center),J(u,u,t.radius);const d=u[2],M=$e(u),x=Math.min(.45+.55*M*M,1)**Ae;J(u,u,t.radius),T!==null&&Q(u,u,T),Me(u,u),s+1!==r.model.lods.length&&r.model.lods.length>1&&Re(u,u,c,d>-1?.2:Math.min(-4*d-3.8,1)),w[g]=u[0],w[g+1]=u[1],w[g+2]=u[2],g+=3,m[f]=x,m[f+1]=x,m[f+2]=x,m[f+3]=1,f+=4}i.attributes.normal=new oe(w.buffer),i.attributes.color=new ne(m.buffer)}}}const Rt=Object.freeze(Object.defineProperty({__proto__:null,fetch:nt,parseUrl:le},Symbol.toStringTag,{value:"Module"}));export{Rt as o,_ as s,nt as z};

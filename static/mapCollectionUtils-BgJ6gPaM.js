import{bj as _,f3 as C,fY as v,eZ as y,fZ as b,cK as w,f_ as p,f$ as I}from"./index-C_bK48d2.js";function M(i,o,e){var s;const a=((s=e==null?void 0:e.createCollection)==null?void 0:s.call(e))??new _,r=e!=null&&e.recycleItems?new $:null,l=(t,n=0)=>{if(!(t!=null&&t.length))return;const c=a.splice(n,t.length);r?r.processRemoved(t):c.forEach(m)},u=(t,n=0)=>{if(!(t!=null&&t.length))return;const c=[];for(const d of t){const g=r==null?void 0:r.use(d);if(g)c.push(g);else{const h=o(d);r==null||r.register(d,h),c.push(h)}}a.addMany(c,n)},f=C(i,"after-splice",({added:t,start:n,removed:c})=>{l(c,n),u(t,n)},{sync:!0,onListenerRemove:t=>l(t.items),onListenerAdd:t=>u(t.items)});return a.addHandles(f),a}class ${constructor(){this._originalToMapped=new Map,this._removedItemCandidates=new Set,this._garbageCollectionQueued=!1}processRemoved(o){var a;if(!(o!=null&&o.length))return;const{_removedItemCandidates:e}=this;for(const r of o)(a=this._getItem(r))!=null&&a.markRemoved()&&(e.add(r),this._queueGarbageCollection())}use(o){const e=this._getItem(o);return e&&(e.removed=!1),e==null?void 0:e.item}register(o,e){this._originalToMapped.set(o,new R(e))}_getItem(o){return this._originalToMapped.get(o)}_queueGarbageCollection(){this._garbageCollectionQueued||(this._garbageCollectionQueued=!0,queueMicrotask(()=>this._garbageCollectCandidates()))}_garbageCollectCandidates(){this._garbageCollectionQueued=!1;const{_removedItemCandidates:o}=this,e=Array.from(o);o.clear(),e.forEach(a=>this._garbageCollectIfRemoved(a))}_garbageCollectIfRemoved(o){const{_originalToMapped:e}=this,a=this._getItem(o);a!=null&&a.removed&&(m(a.item),e.delete(o))}}class R{constructor(o){this.item=o,this.removed=!1}markRemoved(){return this.removed=!0,!0}}function m(i){typeof i=="object"&&i&&("destroy"in i&&typeof i.destroy=="function"?i.destroy():v(i))}function Q(i,o,e){const a=new _,r=M(i,s=>y(async t=>{const n=await o(s,t);if(b(t))throw m(n),w();return n}),e),l=()=>null,u=async s=>{const t=await s.promise,n=r.indexOf(s);n<0||a.splice(n,1,t)};a.addMany(r.items.map(l));for(const s of r)p(u(s));const f=r.on("after-splice",({added:s,start:t,deleteCount:n})=>{const c=a.splice(t,n);for(const d of c)m(d);if(s!=null&&s.length){a.addMany(s.map(l),t);for(const d of s)p(u(d))}});return a.addHandles([I(r),f]),a}export{M as c,Q as u};

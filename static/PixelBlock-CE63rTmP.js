import{aJ as x,aK as m,hz as T,aL as C,bb as M,a as U,a$ as V,aF as k}from"./index-C_bK48d2.js";import{u as G}from"./pixelRangeUtils-BjN-b_zG.js";class v{constructor(t=null,s=null,n=null){this.minValue=t,this.maxValue=s,this.noDataValue=n}}var A,w;let d=(w=class extends M{static createEmptyBand(t,s){return new(A.getPixelArrayConstructor(t))(s)}static combineBandMasks(t){if(t.length<2)return t[0];const s=t[0].length,n=new Uint8Array(s).fill(255);for(let r=0;r<t.length;r++){const a=t[r];for(let e=0;e<s;e++)a[e]||(n[e]=0)}return n}static getPixelArrayConstructor(t){let s;switch(t){case"u1":case"u2":case"u4":case"u8":s=Uint8Array;break;case"u16":s=Uint16Array;break;case"u32":s=Uint32Array;break;case"s8":s=Int8Array;break;case"s16":s=Int16Array;break;case"s32":s=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":s=Float32Array;break;case"f64":s=Float64Array}return s}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let s=t.toLowerCase();return["u1","u2","u4"].includes(s)?s="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(s)||(s="f32"),s}getPlaneCount(){var t;return(t=this.pixels)==null?void 0:t.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new U("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new v)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(n=>P(n,this.mask));const t=this.mask;let s=0;if(t!=null)for(let n=0;n<t.length;n++)t[n]&&s++;else s=this.width*this.height;this.validPixelCount=s}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[s,n]=G(t),r=this.pixels,a=this.width*this.height,e=r.length;let i,o,l;const f=[];for(let c=0;c<e;c++){l=A.createEmptyBand(t,a),i=r[c];for(let u=0;u<a;u++)o=i[u],l[u]=o>n?n:o<s?s:o;f.push(l)}this.pixels=f,this.pixelType=t}extractBands(t){var u;const{pixels:s,statistics:n}=this;if(t==null||t.length===0||!s||s.length===0)return this;const r=s.length,a=t.some(p=>p>=s.length),e=r===t.length&&!t.some((p,h)=>p!==h);if(a||e)return this;const i=((u=this.bandMasks)==null?void 0:u.length)===r?t.map(p=>this.bandMasks[p]):void 0;let{mask:o,validPixelCount:l}=this;const{width:f,height:c}=this;return i!=null&&i.length&&(o=A.combineBandMasks(i),l=o.filter(p=>!!p).length),new A({pixelType:this.pixelType,width:f,height:c,mask:o,bandMasks:i,validPixelCount:l,maskIsAlpha:this.maskIsAlpha,pixels:t.map(p=>s[p]),statistics:n&&t.map(p=>n[p])})}clone(){const t=new A({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let s;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(r=>new Uint8Array(r)));const n=A.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const r=!!this.pixels[0].slice;for(s=0;s<this.pixels.length;s++)t.pixels[s]=r?this.pixels[s].slice():new n(this.pixels[s])}if(this.statistics)for(t.statistics=[],s=0;s<this.statistics.length;s++)t.statistics[s]=V(this.statistics[s]);return t}getTransferableObject(){const{pixels:t,bandMasks:s,mask:n}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const r=this.toJSON();this.pixels=t,this.bandMasks=s,this.mask=n,r.pixels=t&&[...t],r.bandMasks=s&&[...s],r.mask=n;const a=[];return[...t??[],n,...s??[]].filter(e=>e!=null&&ArrayBuffer.isView(e)).forEach(e=>{e&&!a.includes(e.buffer)&&a.push(e.buffer)}),{pixelBlock:r,transferList:a}}_fillFrom8Bit(t){const{mask:s,maskIsAlpha:n,premultiplyAlpha:r,pixels:a}=this;if(!t||!(a!=null&&a.length))return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let e,i,o,l;e=i=o=a[0],a.length>=3?(i=a[1],o=a[2]):a.length===2&&(i=a[1]);const f=new Uint32Array(t),c=this.width*this.height;if(e.length===c)if(s!=null&&s.length===c)if(n)for(l=0;l<c;l++){const u=s[l];if(u){const p=u/255;f[l]=r?u<<24|o[l]*p<<16|i[l]*p<<8|e[l]*p:u<<24|o[l]<<16|i[l]<<8|e[l]}}else for(l=0;l<c;l++)s[l]&&(f[l]=255<<24|o[l]<<16|i[l]<<8|e[l]);else for(l=0;l<c;l++)f[l]=255<<24|o[l]<<16|i[l]<<8|e[l];else k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:s,mask:n,statistics:r}=this;if(!t||!(s!=null&&s.length))return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const a=this.pixelType;let e=1,i=0,o=1;if(r&&r.length>0){for(const g of r)if(g.minValue!=null&&(i=Math.min(i,g.minValue)),g.maxValue!=null&&g.minValue!=null){const B=g.maxValue-g.minValue;o=Math.max(o,B)}e=255/o}else{let g=255;a==="s8"?(i=-128,g=127):a==="u16"?g=65535:a==="s16"?(i=-32768,g=32767):a==="u32"?g=4294967295:a==="s32"?(i=-2147483648,g=2147483647):a==="f32"?(i=-34e38,g=34e38):a==="f64"&&(i=-Number.MAX_VALUE,g=Number.MAX_VALUE),e=255/(g-i)}const l=new Uint32Array(t),f=this.width*this.height;let c,u,p,h,y;if(c=u=p=s[0],c.length!==f)return k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(s.length>=2)if(u=s[1],s.length>=3&&(p=s[2]),n!=null&&n.length===f)for(h=0;h<f;h++)n[h]&&(l[h]=255<<24|(p[h]-i)*e<<16|(u[h]-i)*e<<8|(c[h]-i)*e);else for(h=0;h<f;h++)l[h]=255<<24|(p[h]-i)*e<<16|(u[h]-i)*e<<8|(c[h]-i)*e;else if(n!=null&&n.length===f)for(h=0;h<f;h++)y=(c[h]-i)*e,n[h]&&(l[h]=255<<24|y<<16|y<<8|y);else for(h=0;h<f;h++)y=(c[h]-i)*e,l[h]=255<<24|y<<16|y<<8|y}_fillFrom32Bit(t){const{pixels:s,mask:n}=this;if(!t||!(s!=null&&s.length))return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let r,a,e,i;r=a=e=s[0],s.length>=3?(a=s[1],e=s[2]):s.length===2&&(a=s[1]);const o=this.width*this.height;if(r.length!==o)return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let l=0;if(n!=null&&n.length===o)for(i=0;i<o;i++)t[l++]=r[i],t[l++]=a[i],t[l++]=e[i],t[l++]=1&n[i];else for(i=0;i<o;i++)t[l++]=r[i],t[l++]=a[i],t[l++]=e[i],t[l++]=1}},A=w,w);function P(b,t){let s=1/0,n=-1/0;const r=b.length;let a,e=0;if(t!=null)for(a=0;a<r;a++)t[a]&&(e=b[a],s=e<s?e:s,n=e>n?e:n);else for(a=0;a<r;a++)e=b[a],s=e<s?e:s,n=e>n?e:n;return new v(s,n)}x([m({json:{write:!0}})],d.prototype,"width",void 0),x([m({json:{write:!0}})],d.prototype,"height",void 0),x([m({json:{write:!0}})],d.prototype,"pixelType",void 0),x([T("pixelType")],d.prototype,"castPixelType",null),x([m({json:{write:!0}})],d.prototype,"validPixelCount",void 0),x([m({json:{write:!0}})],d.prototype,"mask",void 0),x([m({json:{write:!0}})],d.prototype,"maskIsAlpha",void 0),x([m({json:{write:!0}})],d.prototype,"pixels",void 0),x([m()],d.prototype,"premultiplyAlpha",void 0),x([m({json:{write:!0}})],d.prototype,"statistics",void 0),x([m({json:{write:!0}})],d.prototype,"depthCount",void 0),x([m({json:{write:!0}})],d.prototype,"noDataValues",void 0),x([m({json:{write:!0}})],d.prototype,"bandMasks",void 0),d=A=x([C("esri.layers.support.PixelBlock")],d);export{d as c,v as l};

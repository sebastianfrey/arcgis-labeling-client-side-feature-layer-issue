import{aJ as x,fk as xe,fj as _e,cT as Ie,o8 as Ne,a as Te,aF as fe}from"./index-C_bK48d2.js";import"./BufferObject--KeRTd-9.js";import"./FramebufferObject-C4D9djRW.js";import{s as Me}from"./ProgramTemplate-ESmcnuBB.js";import{s as ke}from"./ShaderBuilder-DMt-f1fI.js";let un=class{constructor(){this.drawPhase=89}startup(){}shutdown(t){}};function Se(r){return r.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function Pe(r,t){const e=[];for(e.push(t);e.length;){const n=e.pop();if(typeof n=="object"&&!r.has(n.uid)){r.add(n.uid);for(const s of n.children)e.push(s)}}}const mt=class mt{constructor(){this.uid=mt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=Se(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof mt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};mt.NodeCount=0;let K=mt;function c(r){return typeof r=="object"?r.clone():r}let v=class extends K{constructor(){super(...arguments),this.shaderType="primitive-node"}},Ce=class ye extends K{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new ye(c(this.child));return this.cloneInto(t),t}};class Jt extends K{constructor(t,e,n){super(),this.property=t,this.target=e,this.returnType=n,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Jt(this.property,c(this.target),this.returnType);return this.cloneInto(t),t}}let Fe=class me extends K{constructor(t,e,n,s){super(),this.x=t,this.y=e,this.target=n,this.returnType=s,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new me(this.x,this.y,c(this.target),this.returnType);return this.cloneInto(t),t}};class Wt extends K{constructor(t,e,n){super(),this.condition=t,this.ifTrue=e,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=c(this.ifTrue),e=this.ifFalse?c(this.ifFalse):null,n=new Wt(this.condition,t,e);return this.cloneInto(n),n}}let Ee=class ge extends K{constructor(t,e,n,s){super(),this.captureList=t,this.returnType=e,this.generator=s,this.shaderType="block-node",n&&(this.subgraph=new Ce(n))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const n in this.captureList)t[n]=c(this.captureList[n]);const e=new ge(t,this.returnType,this.subgraph?c(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}},B=class be extends K{constructor(t,e,n,s,i,o=!1){super(),this.token=t,this._children=e,this.isInfix=n,this.isPropertyAccess=s,this.returnType=i,this.isTernary=o,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new be(this.token,this._children.map(c),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var yt,Mt,kt,St,A,Pt,Ct,Ft,Et,Kt,Dt,Ut,jt,Ot;function Ke(r){switch(r.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return N;case"float":case"vec2":case"vec3":case"vec4":return y;case"int":case"ivec2":case"ivec3":case"ivec4":return p;case"uint":case"uvec2":case"uvec3":case"uvec4":return b;default:throw new Error("Unable to handle type")}}function De(r){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const e of t)if(e.includes(r))return e.map(n=>Oe[n]);throw new Error("Unable to find type family")}function we(r){return new Proxy(r,{get(t,e){if(e==="constructor")return new Proxy(t.constructor,{construct:(n,s,i)=>we(new n(...s))});if(e in t)return t[e];if(typeof e=="string"){const n=De(r.type);return m(r,e,n[e.length-1])}}})}function T(r){return new Proxy(r,{construct:(t,e,n)=>we(new t(...e))})}function Ue(r){return new Proxy(r,{get(t,e){if(e in t)return t[e];if(typeof e=="string"){const n=parseInt(e,10);if(!isNaN(n))return m(r,`[${n}]`,r.elementType.constructor)}}})}function je(r){return new Proxy(r,{construct:(t,e,n)=>Ue(new t(...e))})}class D extends Error{}var z;let Vt=(z=class extends v{constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new yt(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const n=new p(t),s=e!=null?new p(e):null;return s!=null?Nt(this,n,s,Ke(this.elementType.constructor)):m(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,n){return Be(this,t,e,n)}glslFindIndex(t,e,n){return ze(this,t,e,n)}static ofType(t,e){const n={construct:(s,i)=>new yt(new t,e)};return new Proxy(yt,n)}},yt=z,z.type="array",z);Vt=yt=x([je],Vt);const gt=class gt extends v{constructor(t,e,n,s=!1){super(),this.elementType=t,this.xSize=e,this.ySize=n,this.isRowMajor=s,this.children=[],this.type="array-2d"}clone(){const t=new gt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const n=new p(t);return m(this,new p(e).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const n=new p(t),s=new p(e);return m(this,n.add(s.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,n,s=!1){return new Proxy(Vt,{construct:(i,o)=>new gt(new t,e,n,s)})}};gt.type="array-2d";let ae=gt;const xt=class xt extends v{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new xt;return t.children=this.children.map(c),super.cloneInto(t),t}};xt.type="sampler2D";let ce=xt;var P;let y=(P=class extends v{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new P(c(this.children[0]));return super.cloneInto(t),t}multiply(t){return I(this,typeof t=="number"?d(t,P):t)}divide(t){return k(this,typeof t=="number"?d(t,P):t)}add(t){return M(this,typeof t=="number"?d(t,P):t)}subtract(t){return S(this,typeof t=="number"?d(t,P):t)}},P.type="float",P);var L;let bt=(L=class extends v{constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new Mt(c(this.children[0]),c(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){throw new D}get 3(){throw new D}multiply(t){return I(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}},Mt=L,L.type="vec2",L);bt=Mt=x([T],bt);var q;let $t=(q=class extends v{constructor(t,e,n){super(),this.type="vec3",this.children=[t,e,n].filter(s=>s!=null)}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){throw new D}clone(){const t=new kt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(t),t}multiply(t){return I(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}},kt=q,q.type="vec3",q);$t=kt=x([T],$t);var R;let nt=(R=class extends v{constructor(t,e,n,s){super(),this.type="vec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new St(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){return m(this,"[3]",y)}multiply(t){return I(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}},St=R,R.type="vec4",R);nt=St=x([T],nt);var G;let b=(G=class extends v{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new A(c(this.children[0]));return super.cloneInto(t),t}multiply(t){return I(this,d(t,A))}add(t){return M(this,d(t,A))}subtract(t){return S(this,d(t,A))}divide(t){return k(this,d(t,A))}},A=G,G.type="uint",G);b=A=x([T],b);var H;let At=(H=class extends v{constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new Pt(c(this.children[0]),c(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",p)}get 1(){return m(this,"[1]",p)}get 2(){throw new D}get 3(){throw new D}multiply(t){return I(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}},Pt=H,H.type="uvec2",H);At=Pt=x([T],At);var X;let Bt=(X=class extends v{constructor(t,e,n){super(),this.type="uvec3",this.children=[t,e,n].filter(s=>s!=null)}clone(){const t=new Ct(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){throw new D}multiply(t){return I(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}},Ct=X,X.type="uvec3",X);Bt=Ct=x([T],Bt);var Y;let zt=(Y=class extends v{constructor(t,e,n,s){super(),this.type="uvec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new Ft(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){return m(this,"[3]",b)}multiply(t){return I(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}},Ft=Y,Y.type="uvec4",Y);zt=Ft=x([T],zt);const _t=class _t extends v{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return Xe(this,t)}or(t){return qe(this,t)}xor(t){return Ge(this,t)}clone(){const t=new _t(c(this.children[0]));return super.cloneInto(t),t}};_t.type="bool";let N=_t;var Q;let Lt=(Q=class extends v{constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(n=>n!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Et(c(this.children[0]),c(this.children[1]));return super.cloneInto(t),t}},Et=Q,Q.type="bvec2",Q);Lt=Et=x([T],Lt);var Z;let qt=(Z=class extends v{constructor(t,e,n){super(),this.type="bvec3",this.children=[t,e,n].filter(s=>s!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Kt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(t),t}},Kt=Z,Z.type="bvec3",Z);function d(r,t){return typeof r=="number"?new t(r):r}qt=Kt=x([T],qt);var J;let Rt=(J=class extends v{constructor(t,e,n,s){super(),this.type="bvec4",this.children=[t,e,n,s].filter(i=>i!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Dt(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}},Dt=J,J.type="bvec4",J);Rt=Dt=x([T],Rt);const j=class j extends v{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return I(this,d(t,j))}add(t){return M(this,d(t,j))}subtract(t){return S(this,d(t,j))}divide(t){return k(this,d(t,j))}clone(){const t=new j(c(this.children[0]));return super.cloneInto(t),t}};j.type="int";let p=j;var W;let Gt=(W=class extends v{constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new Ut(c(this.children[0]),c(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",p)}get 1(){return m(this,"[1]",p)}get 2(){throw new D}get 3(){throw new D}multiply(t){return I(this,typeof t=="number"?d(t,p):t)}divide(t){return k(this,typeof t=="number"?d(t,p):t)}add(t){return M(this,typeof t=="number"?d(t,p):t)}subtract(t){return S(this,typeof t=="number"?d(t,p):t)}},Ut=W,W.type="ivec2",W);Gt=Ut=x([T],Gt);var tt;let Ht=(tt=class extends v{constructor(t,e,n){super(),this.type="ivec3",this.children=[t,e,n].filter(s=>s!=null)}clone(){const t=new jt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",p)}get 1(){return m(this,"[1]",p)}get 2(){return m(this,"[2]",p)}get 3(){throw new D}multiply(t){return I(this,typeof t=="number"?d(t,p):t)}divide(t){return k(this,typeof t=="number"?d(t,p):t)}add(t){return M(this,typeof t=="number"?d(t,p):t)}subtract(t){return S(this,typeof t=="number"?d(t,p):t)}},jt=tt,tt.type="ivec3",tt);Ht=jt=x([T],Ht);var et;let Xt=(et=class extends v{constructor(t,e,n,s){super(),this.type="ivec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new Ot(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",p)}get 1(){return m(this,"[1]",p)}get 2(){return m(this,"[2]",p)}get 3(){return m(this,"[3]",p)}multiply(t){return I(this,typeof t=="number"?d(t,p):t)}divide(t){return k(this,typeof t=="number"?d(t,p):t)}add(t){return M(this,typeof t=="number"?d(t,p):t)}subtract(t){return S(this,typeof t=="number"?d(t,p):t)}},Ot=et,et.type="ivec4",et);Xt=Ot=x([T],Xt);const It=class It extends v{constructor(t,e,n,s){super(),this.type="mat2",this.children=[t,e,n,s]}clone(){const t=new It(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}get(t,e){return Nt(this,new p(t),new p(e),y)}multiply(t){return I(this,t)}};It.type="mat2";let ue=It;const it=class it extends v{static identity(){return new it(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=Ze(t),n=Qe(t);return new it(n,e,0,Ae(e),n,0,0,0,1)}constructor(t,e,n,s,i,o,h,u,a){super(),this.type="mat3",this.children=[t,e,n,s,i,o,h,u,a]}add(t){return M(this,t)}multiply(t){return I(this,t)}get(t,e){return Nt(this,new p(t),new p(e),y)}clone(){const t=new it(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]),c(this.children[4]),c(this.children[5]),c(this.children[6]),c(this.children[7]),c(this.children[8]));return super.cloneInto(t),t}};it.type="mat3";let Yt=it;const ot=class ot extends v{static identity(){return new ot(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,n,s,i,o,h,u,a,l,f,w,F,rt,O,E){super(),this.type="mat4",this.children=[t,e,n,s,i,o,h,u,a,l,f,w,F,rt,O,E]}static fromColumns(t,e,n,s){return new ot(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,n.x,n.y,n.z,n.w,s.x,s.y,s.z,s.w)}multiply(t){return I(this,t)}get(t,e){return Nt(this,new p(t),new p(e),y)}clone(){const t=new ot(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]),c(this.children[4]),c(this.children[5]),c(this.children[6]),c(this.children[7]),c(this.children[8]),c(this.children[9]),c(this.children[10]),c(this.children[11]),c(this.children[12]),c(this.children[13]),c(this.children[14]),c(this.children[15]));return super.cloneInto(t),t}};ot.type="mat4";let he=ot;const Oe={float:y,vec2:bt,vec3:$t,vec4:nt,int:p,ivec2:Gt,ivec3:Ht,ivec4:Xt,uint:b,uvec2:At,uvec3:Bt,uvec4:zt,bool:N,bvec2:Lt,bvec3:qt,bvec4:Rt},pn=(...r)=>new p(...r),Ve=(...r)=>new y(...r),ln=(...r)=>new bt(...r),fn=(...r)=>new $t(...r),yn=(...r)=>new nt(...r),mn=(...r)=>new Yt(...r);function m(r,t,e){const n=new e(new Jt(t,r,e));return n.isImplicit=!0,n}function Nt(r,t,e,n){const s=new n(new Fe(t,e,r,n));return s.isImplicit=!0,s}function $(r,t,e,n=null){if(n){const i=new n,o=new n(new B(r,[t,e],!0,!1,i));return o.isImplicit=!0,o}if(t.type==="float"||t.type==="int"){const i=new e.constructor(new B(r,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&e.type!=="float"){const i=new e.constructor(new B(r,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}const s=new t.constructor(new B(r,[t,e],!0,!1,t.constructor));return s.isImplicit=!0,s}function g(r,t,e=t.constructor){const n=new e(new B(r,[t],!1,!1,e));return n.isImplicit=!0,n}function U(r,t,e,n=t.constructor){const s=new n(new B(r,[t,e],!1,!1,n));return s.isImplicit=!0,s}function Tt(r,t,e,n,s=t.constructor){const i=new s(new B(r,[t,e,n],!1,!1,s));return i.isImplicit=!0,i}function Ae(r){return I(r,Ve(-1))}function te(r,t,e,n){return new t(new Ee(r,t,e,n))}function Be(r,t,e=0,n=r.size){const s=new p(e).setMutable().setDebugName("FindIndexIterator"),i=t(r.get(s)).setDebugName("FindIndexPredicate");return te({iter:s},p,i,({out:h,iter:u,subgraph:a})=>`
${h} = -1;

for (; ${u} < ${n}; ${u}++) {

${a.body}

  if (${a.varName}) {
    ${h} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function ze(r,t,e=0,n=r.size){return te({array:r},p,null,({out:i,array:o})=>`
${i} = -1;
for (int i = ${e}; i < ${n}; i++) {
  bool condition;
  ${t({array:o,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function Le(r,t,e){const n=typeof t=="function"?t():t,s=typeof e=="function"?e():e,i=new n.constructor(new Wt(r,n,s));return i.isImplicit=!0,i}function gn(...r){const t=r.map(([h,u])=>typeof u=="function"?[h,u()]:[h,u]),e=t[0][1].constructor,n=t.findIndex(h=>h[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const s=t.slice(0,n),i=t[n][1],o=new e(s.reduceRight((h,u)=>Le(u[0],u[1],h),i));return o.isImplicit=!0,o}function I(r,t){return $("*",r,t)}function k(r,t){return $("/",r,t)}function M(r,t){return $("+",r,t)}function S(r,t){return $("-",r,t)}function bn(r,t){return $("%",r,t)}function wn(r,t){return $("<<",r,t)}function vn(r,t){return $(">>",r,t)}function $n(r,t){return $("&",r,t)}function xn(r,t){return $("|",r,t)}function _n(r,t){return $("^",r,t)}function In(r){return g("~",r)}function Nn(r,t){return $("==",r,t,N)}function Tn(r,t){return $("!=",r,t,N)}function Mn(r,t){return $("<",r,t,N)}function kn(r,t){return $("<=",r,t,N)}function Sn(r,t){return $(">",r,t,N)}function Pn(r,t){return $(">=",r,t,N)}function qe(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>Re(t,e),r[0])}function Re(r,t){return $("||",r,t,N)}function Ge(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>He(t,e),r[0])}function He(r,t){return $("^^",r,t,N)}function Xe(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>Ye(t,e),r[0])}function Ye(r,t){return $("&&",r,t,N)}function Cn(r){return g("abs",r)}function Fn(r){return g("acos",r)}function En(r){return g("acosh",r)}function ee(r){return g("all",r,N)}function ne(r){return g("any",r,N)}function Kn(r){return g("asin",r)}function Dn(r){return g("asinh",r)}function Un(r,t){return t==null?g("atan",r):U("atan",r,t,r.constructor)}function jn(r){return g("atanh",r)}function On(r){return g("ceil",r)}function Vn(r,t,e){return Tt("clamp",r,t,e,r.constructor)}function Qe(r){return g("cos",r)}function An(r){return g("cosh",r)}function Bn(r,t){return U("distance",r,t,y)}function zn(r,t){return U("dot",r,t,y)}function Ln(r){return g("exp",r)}function qn(r){return g("floor",r)}function Rn(r){return g("fract",r)}function Gn(r){return g("length",r,y)}function Hn(r){return g("log",r)}function Xn(r){return g("log2",r)}function Yn(r,t){return U("max",r,t)}function Qn(r,t){return U("min",r,t)}function Zn(r,t,e){return Tt("mix",r,t,e)}function Jn(r,t){return U("mod",r,t)}function Wn(r){return g("normalize",r)}function tr(r){return r.type==="bool"?g("!",r):g("not",r)}function er(r,t){return U("pow",r,t)}function nr(r){return g("round",r)}function rr(r){return g("sign",r)}function Ze(r){return g("sin",r)}function sr(r){return g("sinh",r)}function ir(r,t,e){return Tt("smoothstep",r,t,e)}function or(r){return g("sqrt",r)}function ar(r,t){return U("step",r,t,t.constructor)}function cr(r){return g("tan",r)}function ur(r){return g("tanh",r)}function hr(r,t,e){return Tt("texelFetch",r,t,e,nt)}function dr(r,t){return U("texture",r,t,nt)}function pr(r,t){const{initialValue:e,xRange:n,yRange:s,callback:i}=t,[o,h]=n,[u,a]=s,l=new p(0).setMutable().setDebugName("iterX"),f=new p(0).setMutable().setDebugName("iterY"),w=e.setMutable().setDebugName("accumulator"),F=i(w,r.get(l,f),l,f).setDebugName("callback");return te({iterX:l,iterY:f,accumulator:w},e.constructor,F,({out:O,iterX:E,iterY:V,accumulator:ct,subgraph:ut})=>`
for (${V} = ${u}; ${V} < ${a}; ${V}++) {
  for (${E} = ${o}; ${E} < ${h}; ${E}++) {

  ${ut.body}

  ${ct} = ${ut.varName};
  }
}
${O} = ${ct};
`).setDebugName("reduce2DBody")}const pt=5;function _(r,t,e){const n=t.split(`
`);for(const s of n)if(s.trim().length){{let i="";e!=null&&(i+=`/*id:${e??"000"}*/   `),r.body+=i.padEnd(14)}r.body+=" ".repeat(r.indent)+s+`
`}}class de{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let n="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(n=`${e.debugInfo.name}_`),`${n}v${t.varCount++}`}_write(t,e,n=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let s=t.getEmit(e);if(s)return s;switch(e.shaderType){case"scope-node":s=this._writeScopeNode(t,e);break;case"primitive-node":s=this._writePrimitiveNode(t,e,n);break;case"function-node":s=this._writeFunctionNode(t,e);break;case"property-access-node":s=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":s=this._writePropertyAccess2DNode(t,e);break;case"text-node":s=e.text;break;case"block-node":s=this._writeBlockNode(t,e);break;case"condition-node":s=this._writeConditionNode(t,e)}return t.setEmit(e,s),s}_writeScopeNode(t,e){const n=new e.child.constructor;n.setDebugName(e.debugInfo.name);const s=this._write(t,n,!0);return _(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,_(t,`${s} = ${this._write(t,e.child)};`),t.indent-=2,_(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),s}_writeConditionNode(t,e){const n=new e.ifTrue.constructor,s=this._write(t,n,!0);_(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),o=this._write(i,e.ifTrue);if(t.body+=i.body,o&&_(t,`${s} = ${o};`),t.indent-=2,_(t,"}"),e.ifFalse){_(t,"else {"),t.indent+=2;const h=t.createSubgraphContext(),u=this._write(h,e.ifFalse);t.body+=h.body,u&&_(t,`${s} = ${u};`),t.indent-=2,_(t,"}")}return s}_writeBlockNode(t,e){const{captureList:n,generator:s,returnType:i}=e,o={};for(const l in n){if(!n[l])continue;const f=this._write(t,n[l]);o[l]=f}const h=new i,u=this._write(t,h,!0);if(o.out=u,e.subgraph){const l=t.createSubgraphContext(),f=this._write(l,e.subgraph.child),w=l.body;o.subgraph={varName:f,body:w}}const a=s(o);return _(t,`{
`),t.indent+=2,_(t,a),t.indent-=2,_(t,`}
`),u}_writePropertyAccessNode(t,e){const n=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${n}${e.property}`:typeof e.property!="string"?`${n}[${this._write(t,e.property)}]`:`${n}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const n=e.returnType.type;if(e.isInfix){const[o,h]=e.children.map(a=>this._write(t,a)),u=this._createVarName(t,e);return _(t,`${n.padEnd(pt)} ${u} = ${o} ${e.token} ${h};`,e.uid),u}const s=e.children.map(o=>this._write(t,o)).join(", "),i=this._createVarName(t,e);return _(t,`${n.padEnd(pt)} ${i} = ${e.token}(${s});`,e.uid),i}_writePrimitiveNode(t,e,n=!1){var a;const s=t.getInput(e);if(s)return s.isUsed=!0,s.variableName;const i=e.children.length===1&&((a=e.children[0])==null?void 0:a.type)===e.type;if(!e.isMutable&&(e.isImplicit||i))return this._write(t,e.children[0]);const o=this._createVarName(t,e);if(n)return _(t,`${e.type.padEnd(pt)} ${o};`,e.uid),o;const h=!e.debugInfo.name&&!e.isMutable;if(h&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(h&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const u=e.children.map(l=>this._write(t,l)).join(", ");return e.type==="array"?(_(t,`${e.type.padEnd(pt)} ${o} = [${u}];`,e.uid),o):h?`${e.type}(${u})`:(_(t,`${e.type.padEnd(pt)} ${o} = ${e.type}(${u});`,e.uid),o)}}let st=class ve{constructor(t,e,n,s=[]){this.variableName=t,this.variableInputType=e,this.node=n,this.qualifiers=s,this.type="shader-input",this.isUsed=!1}clone(){return new ve(this.variableName,this.variableInputType,c(this.node),[...this.qualifiers])}},C=class $e{constructor(t,e,n,s=[]){this.outVariableName=t,this.outVariableType=e,this.node=n,this.qualifiers=s,this.type="shader-output"}clone(){const t=new $e(this.outVariableName,this.outVariableType,c(this.node),[...this.qualifiers]);return t.variableName=this.variableName,t}},pe=class vt{static createVertex(t,e,n,s,i,o){const h=[];for(const a in t){const l=t[a],f=n.get(a);f?h.push(new st(f,"builtin",l)):h.push(new st("a_"+a,"in",l))}for(const a of s){const l=a.uniformHydrated;h.push(new st(a.uniformName,"uniform",l))}const u=[];for(const a in e){const l=e[a];if(a==="glPosition")u.push(new C("gl_Position","builtin",l));else if(a==="glPointSize")u.push(new C("gl_PointSize","builtin",l));else{const f=Je(l),w=[];f&&w.push(f),u.push(new C("v_"+a,"out",l,w))}}return new vt(h,u,i,o)}static createFragment(t,e,n,s,i,o){const h=[],u=Array.from(i.rootOutputNodes());for(const l in t){const f=t[l],w=n.get(l);if(w){h.push(new st(w,"builtin",f));continue}const F=u.find(rt=>rt.node===f);F&&h.push(new st(F.outVariableName,"in",f))}for(const l of s){const f=l.uniformHydrated;h.push(new st(l.uniformName,"uniform",f))}const a=[];for(const l in e){const f=e[l],w=n.get(l);switch(l){case"discard":a.push(new C(null,"discard",f));break;case"fragData0":a.push(new C("fragData0","fragData0",f));break;case"fragData1":a.push(new C("fragData1","fragData1",f));break;case"fragData2":a.push(new C("fragData2","fragData2",f));break;case"fragData3":a.push(new C("fragData3","fragData3",f));break;default:w?a.push(new C(w,"builtin",f)):a.push(new C(l,"out",f))}}return new vt(h,a,o)}constructor(t,e,n,s){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const i of t)this._inputShaderTypesByNodeUid.set(i.node.uid,i);this._outputShaderTypes=e,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(i=>"v_"+i.propertyKey)),this._usedInFragmentShader=s}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();typeof e!="number"&&typeof e!="boolean"&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new vt([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const n=e.outVariableType==="builtin";if(!this.shouldPruneOutputNode(e))if(n)t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`);else{const s=[...e.qualifiers,e.outVariableType].join(" ");t.vertex.code.add(`${s.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`)}}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?t.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.outputs.add(n.outVariableName,n.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${n.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())if(n.isUsed&&n.variableInputType!=="builtin")if(n.node.type==="array")t[e].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`);else if(n.node.type==="array-2d")t[e].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const s=[...n.qualifiers,n.variableInputType].join(" ");t[e].code.add(` ${s.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`)}}};function Je(r){switch(r.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${r.type} is not a valid output type`)}}function We(r,t,e){const n=new xe(t.width,t.height);return n.dataType=t.dataType,t.depth&&(n.depth=t.depth),t.flipped&&(n.flipped=t.flipped),t.hasMipmap&&(n.hasMipmap=t.hasMipmap),n.internalFormat=t.internalFormat,t.isImmutable&&(n.isImmutable=t.isImmutable),t.isOpaque&&(n.isOpaque=t.isOpaque),t.maxAnisotropy&&(n.maxAnisotropy=t.maxAnisotropy),n.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(n.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(n.samplingMode=t.samplingMode),t.target&&(n.target=t.target),t.unpackAlignment&&(n.unpackAlignment=t.unpackAlignment),t.wrapMode&&(n.wrapMode=t.wrapMode),new _e(r,n,e)}const tn=()=>fe.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function lt(r,t,e){const n=t.length;if(n!==e){const s=new Te("Invalid Uniform",`Invalid length, expected ${e} but got ${n}`,{uniformName:r,values:t});tn().errorOnce(s)}}let le=class{constructor(t,e,n,s,i){this.vertexShader=t,this.fragmentShader=e,this._locations=n,this._uniformBindings=s,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=Ie(this._program),this.cleanupTemporaryTextures()}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const s=[];for(const i of this._transformFeedbackBindings??[]){const{index:o,propertyKey:h}=i;s[o]=`v_${h}`}this._program=new Me(t,this.vertexShader,this.fragmentShader,this._locations,new Map,s)}const n=this._program;t.useProgram(n);for(const s of this._uniformBindings){const{shaderModulePath:i,uniformName:o,uniformType:h,uniformArrayLength:u}=s,a=Ne(i,e);if(a==null){if(h==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(h==="array"||h==="array-2d"?s.uniformArrayElementType:h){case"sampler2D":{const{unit:l,texture:f}=a;if(n.setUniform1i(o,l),"type"in f)t.bindTexture(f,l);else{const w=We(t,f.descriptor,f.data);t.bindTexture(w,l)}break}case"int":if(!u){n.setUniform1i(o,a);break}lt(s.uniformName,a,u),n.setUniform1iv(o,a);break;case"float":if(!u){n.setUniform1f(o,a);break}lt(s.uniformName,a,u),n.setUniform1fv(o,a);break;case"vec2":if(!u){n.setUniform2f(o,a[0],a[1]);break}lt(s.uniformName,a,u),n.setUniform2fv(o,a.flat());break;case"vec3":if(!u){n.setUniform3f(o,a[0],a[1],a[2]);break}lt(s.uniformName,a,u),n.setUniform3fv(o,a.flat());break;case"vec4":if(!u){n.setUniform4f(o,a[0],a[1],a[2],a[3]);break}lt(s.uniformName,a,u),n.setUniform4fv(o,a.flat());break;case"mat3":n.setUniformMatrix3fv(o,a);break;case"mat4":n.setUniformMatrix4fv(o,a);break;default:throw new Error(`Unable to set uniform for type ${h}`)}}}};function ft(r){return new r}function at(r,t,e){const n=r.constructor[t]??[];r.constructor.hasOwnProperty(t)||Object.defineProperty(r.constructor,t,{value:n.slice()}),r.constructor[t].push(e)}function fr(r,t){return(e,n)=>{at(e,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:r})}}const en=r=>(t,e)=>{at(t,"builtins",{builtin:r,propertyKey:e})},yr=r=>(t,e,n)=>{at(t,"inputs",{inputCtor:r,propertyKey:e,parameterIndex:n})},mr=r=>(t,e)=>{at(t,"uniforms",{typeCtor:r,propertyKey:e})},gr=r=>(t,e)=>{at(t,"options",{typeCtor:r,propertyKey:e})},br=(r,t)=>{at(r,"defines",{propertyKey:t})},Qt=(r,t)=>(e,n)=>{e.constructor.builtins.push({builtin:r,propertyKey:n,typeCtor:t})},re=class re{};re.builtins=[];let Zt=re;x([Qt("gl_VertexID",p)],Zt.prototype,"glVertexID",void 0);class wr{}const se=class se{};se.builtins=[];let wt=se;x([Qt("gl_FragCoord",nt)],wt.prototype,"glFragCoord",void 0),x([Qt("gl_PointCoord",bt)],wt.prototype,"glPointCoord",void 0);let nn=class{};x([en("gl_FragDepth")],nn.prototype,"glFragDepth",void 0);let $r=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},_r=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var t;return[...this.vertexInput.inputCtor.locations,...((t=this.computeInput)==null?void 0:t.inputCtor.locations)??[]]}get locationsMap(){const t=new Map,e=new Set;for(const n of this.locations)e.has(n.index)?fe.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:t}):(t.set(n.propertyKey,n.index),e.add(n.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([s,i])=>`${s}.${i}`).join("."),n=this.computeAttributes;this._locationInfo={stringHash:e,locations:t,computeAttributeMap:n}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,n,s){try{const{vertex:i,fragment:o,uniformBindings:h}=this._generateShaders(t,e,n,s);return new le(i,o,this.renamedLocationsMap,h,this.transformFeedbackBindings)}catch{return new le("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(s=>s.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const n=this._uniforms.find(s=>s.propertyKey===t);if(!n)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:n.typeCtor}}getShaderKey(t,e,n,s){const i=Object.keys(t).map(a=>`${a}.${t[a]}`).join("."),o=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),h=Object.keys(s).map(a=>`${a}.${s[a]}`).join("."),u=Object.keys(e).filter(a=>this.optionPropertyKeys.has(a)&&e[a]).join(".");return`${this.type}.${i}.${o}.${h}.${u}`}_generateShaders(t,e,n,s){const i=[];this._setDefines(n),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const o=this._hydrateVertexInput(s),h=this._injectPackPrecisionFactor(o,t),u=this._hydrateComputeInput(),a=u&&this._injectComputePackPrecisionFactor(u,t),l=this.vertex(h,a),f=this._hydrateFragmentInput(l),w=this.fragment(f),F=new Set;for(const ht in w){const dt=w[ht];Pe(F,dt)}const rt=this._getVertexInputBuiltins(),O={};for(const[ht,dt]of Object.entries(o))O[ht]=dt;if(u!=null)for(const[ht,dt]of Object.entries(u))O[ht]=dt;const E=pe.createVertex(O,l,rt,i,this.transformFeedbackBindings,F);new de().write(E);const V=this._getFragmentInputBuiltins(w);V.set("glPointCoord","gl_PointCoord"),V.set("glFragCoord","gl_FragCoord");const ct=pe.createFragment(f,w,V,i,E,this.transformFeedbackBindings);new de().write(ct);const ut=this._createShaderBuilder(E,ct),ie=ut.generate("vertex"),oe=ut.generate("fragment");return this.logShader&&(console.log(ie),console.log(oe)),{vertex:ie,fragment:oe,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const n of this._options)e[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(t,n):this[n.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const n=new e.typeCtor;for(const s of n._uniforms??[]){const i=ft(s.typeCtor),o=`u_${e.propertyKey}_${s.propertyKey}`,h=i.type,u=[e.propertyKey,s.propertyKey].join(".");if("type"in s.typeCtor&&s.typeCtor.type==="array"){const a=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in s.typeCtor&&s.typeCtor.type==="array-2d"){const a=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformHydrated:i});n[s.propertyKey]=i}return n}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,n=e.locations.reduce((s,i)=>t[i.propertyKey]===!1?s:{...s,[i.propertyKey]:ft(i.typeCtor)},{});for(const{propertyKey:s,typeCtor:i}of e.builtins){const o=ft(i);n[s]=o}return n}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:ft(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const n={};for(const s in t){const i=t[s],o=e[s];if(o){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[s]=i.divide(new y(o))}else n[s]=i}return n}_injectComputePackPrecisionFactor(t,e){const n={},s=new Map;for(const i in this.computeAttributes)for(const o of this.computeAttributes[i]??[])s.set(o,i);for(const i in t){const o=t[i],h=s.get(i);if(!h)continue;const u=e[h];if(u){if(o.type!=="float"&&o.type!=="vec2"&&o.type!=="vec3"&&o.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${o.type}`);n[i]=o.divide(new y(u))}else n[i]=o}return n}_hydrateFragmentInput(t){const e={};for(const n in t)e[n]=t[n];for(const{propertyKey:n,typeCtor:s}of wt.builtins){const i=ft(s);e[n]=i}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:n,propertyKey:s}of t.builtins)e.set(s,n);return e}_getFragmentInputBuiltins(t){const e=t.constructor,n=new Map;for(const s of e.builtins??[])n.set(s.propertyKey,s.builtin);return n}_createShaderBuilder(t,e){const n=new ke;return this._insertDebugInfo(n),t.insertVertexShader(n),e.insertFragmentShader(n),n}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{gr as $,kn as A,or as B,Nn as C,Mn as D,Vt as E,ir as F,Jn as G,Ln as H,wt as I,he as J,Un as K,Gn as L,Qe as M,p as N,nr as O,_r as P,Cn as Q,I as R,bn as S,Rn as T,ce as U,pn as V,er as W,Yn as X,$t as Y,On as Z,nt as _,Sn as a,wr as a0,Pn as a1,qe as a2,N as a3,Ae as a4,ue as a5,te as a6,Bn as a7,Xe as a8,tr as a9,pr as aA,Wn as aa,mn as ab,vn as ac,$n as ad,le as ae,hr as af,Gt as ag,rr as ah,Tn as ai,Ge as aj,_n as ak,In as al,wn as am,xn as an,ur as ao,cr as ap,sr as aq,An as ar,jn as as,Dn as at,Kn as au,En as av,Fn as aw,Xn as ax,Hn as ay,ae as az,y as b,bt as c,dr as d,Zn as e,fr as f,yr as g,fn as h,Zt as i,$r as j,un as k,yn as l,mr as m,br as n,ln as o,Le as p,Vn as q,Yt as r,Ve as s,Qn as t,Ze as u,nn as v,zn as w,ar as x,gn as y,qn as z};

const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-3ft81lFk.js","./geometryEngineBase-DlBBq5gp.js","./_commonjsHelpers-DCkdB7M8.js"])))=>i.map(i=>d[i]);
import{a as z,gA as ge,cz as ue,cA as ce,cs as U,ct as Me,gI as ie,aa as B,cy as xe,gG as ae,_ as He,oZ as Je,io as _e,ox as Ue,o_ as Le,a$ as L,cw as Ye,ec as te,dw as We,c_ as Xe,o$ as Ke,cF as Fe,eW as et,p0 as V,aO as tt,bi as we,aX as Ie,jp as it,fn as st,fm as at,fp as rt,cS as Se,fC as nt,hQ as lt,d7 as ot,bY as Te,bQ as ut,dy as ct,du as dt,f9 as re,fE as ht}from"./index-C_bK48d2.js";import{H as ft}from"./featureConversionUtils-Di1UhLmY.js";import{WhereClauseCache as mt}from"./WhereClauseCache-Bg00WU4t.js";import{i as Y,s as W,o as ne,I as De,n as yt,h as H,l as pt,w as qe}from"./timeSupport-CKl_T9CO.js";import{a as N,h as G,f as he,S as C,x as gt,B as xt,w as Re,M as _t}from"./queryUtils-CqfgZPYW.js";import{t as Ft}from"./QueryEngineCapabilities-zq1XKmMU.js";import{s as be}from"./quantizationUtils-DpuTGthe.js";import{b as wt}from"./utils-FyH5DJme.js";import{m as le,B as It,d as St,f as ve,p as Ae,C as Tt,k as Rt,$ as bt,E as vt,P as At,U as Qt,g as Vt,v as zt,L as Et,G as Qe}from"./utils-CMB00zbv.js";import{e as Bt,s as Ve}from"./SnappingCandidate-Bp4AgyW0.js";import{d as Mt,c as Dt,b as qt,m as Gt,s as Ct}from"./FixedIntervalBinParameters-DSGmyRFU.js";const Ge=new mt(50,500),X="unsupported-query",Ce=" as ",Ne=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),Oe=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Nt=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...Ne,...Oe]);function fe(o,e,t={}){const i=O(e,o);if(!i){const a=Ge.getError(e,o);throw new z(X,"invalid SQL expression",{expression:e,error:a})}const s=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new z(X,`${s} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new z(X,`${s} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function Ot(o,e,t,i){if(!t)return!0;const s="where clause";return D(o,e,fe(o,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:i}),!0}function Pt(o,e,t,i,s){if(!t)return!0;const a="having clause",r=fe(o,t,{validateAggregate:!0,expressionName:a});D(o,e,r,{expressionName:a,query:s});const n=O(t,o);if(!(n==null?void 0:n.getExpressions().every(u=>{var f;const{aggregateType:c,field:d}=u,h=(f=o.get(d))==null?void 0:f.name;return i.some(m=>{var T;const{onStatisticField:x,statisticType:_}=m;return((T=o.get(x))==null?void 0:T.name)===h&&_.toLowerCase().trim()===c})})))throw new z(X,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function O(o,e){return o?Ge.get(o,e):null}function Pe(o){return/\((.*?)\)/.test(o)?o:o.split(Ce)[0]}function $t(o){return o.split(Ce)[1]}function D(o,e,t,i={}){const s=new Map;if(Zt(s,o,e,i.allowedFieldTypes??Nt,t),s.size){const a=i.expressionName??"expression";throw new z(X,`${a} contains invalid or missing fields`,{errors:Array.from(s.values()),query:i.query})}}function Zt(o,e,t,i,s){const a=s.includes("*")?[...t,...s.filter(r=>r!=="*")]:s;for(const r of a)if(e.get(r))ze(o,e,t,i,r);else try{const n=fe(e,Pe(r),{validateStandardized:!0});for(const l of n)ze(o,e,t,i,l)}catch(n){o.set(r,{type:"expression-error",expression:r,error:n})}}function ze(o,e,t,i,s){const a=e.get(s);a?t.has(a.name)?i!=="all"&&(i==null?void 0:i.has(a.type))===!1&&o.set(s,{type:"invalid-type",fieldName:a.name,fieldType:ge.fromJSON(a.type),allowedFieldTypes:Array.from(i,r=>ge.fromJSON(r))}):o.set(s,{type:"missing-field",fieldName:a.name}):o.set(s,{type:"invalid-field",fieldName:s})}const jt=5;class kt{constructor(){this._storage=new Map,this._purgeInterval=jt,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){var e;(e=this._storage)==null||e.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){var i;(i=this._storage)==null||i.set(e,new Jt(t)),this._scheduleSweep()}get(e){var i,s,a;const t=(i=this._storage)==null?void 0:i.get(e);if(t)return(s=this._storage)==null||s.delete(e),t.time=performance.now(),(a=this._storage)==null||a.set(e,t),t.items}clear(){var e;(e=this._storage)==null||e.clear()}_scheduleSweep(){this._storage&&(this._timer??(this._timer=setTimeout(this._sweep,1e3*this._purgeInterval)))}get test(){}}let Ht=0;class Jt{constructor(e){this.items=e,this.time=performance.now(),this.id=Ht++}}let J=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let a=0;for(const r of s){const n=Pe(r),l=this.fieldsIndex.get(n),u=l?null:O(n,i),c=l?l.name:$t(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){var r;if(i)return this.featureAdapter.getAttribute(e,i.name);const s=t;let a=null;return this._fieldDataCache.has(s)?a=(r=this._fieldDataCache.get(s))==null?void 0:r.clause:i||(a=O(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),a==null?void 0:a.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const s=t.normalizationType,a=t.normalizationTotal,r=this.fieldsIndex.get(t.field),n=ue(r)||ce(r),l=U(r);return e.map(u=>{let c=t.field&&this.getFieldValue(u,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${le(c)}${t.fieldDelimiter}${le(this.getFieldValue(u,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${le(this.getFieldValue(u,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&i&&(n?c=c?new Date(c).getTime():null:l&&(c=c?wt(c):null)),s&&Number.isFinite(c)){const d=s==="field"&&t.normalizationField?this.getFieldValue(u,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=It(c,s,d,a)}return c})}async getExpressionValues(e,t,i,s,a){const{arcadeUtils:r}=await Me(),n=r.hasGeometryOperations(t);n&&await r.enableGeometryOperations();const l=r.createFunction(t),u=r.getViewInfo(i),c={fields:this.fieldsIndex.fields};return e.map(d=>{const h={attributes:this.featureAdapter.getAttributes(d),layer:c,geometry:n?{...Y(s.geometryType,this.featureAdapter.getGeometry(d)),spatialReference:i==null?void 0:i.spatialReference}:null},f=r.createExecContext(h,u,a);return r.executeFunction(l,f)})}validateItem(e,t){var i,s;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:O(t,this.fieldsIndex)}),((s=(i=this._fieldDataCache.get(t))==null?void 0:i.clause)==null?void 0:s.testFeature(e,this.featureAdapter))??!1}validateItems(e,t){var i,s;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:O(t,this.fieldsIndex)}),((s=(i=this._fieldDataCache.get(t))==null?void 0:i.clause)==null?void 0:s.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!(t!=null&&t.length))return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:a,clause:r}=this._fieldDataCache.get(s);i[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return i}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const r of t){const{alias:n}=this._fieldDataCache.get(r);i.push(e[n])}else for(const r in e)i.push(e[r]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let a=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++a),a>1?null:e}};const j="bin";class A{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new J(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!(t==null?void 0:t.length))return 1;const r=new Map,n=new Map,l=new Set;for(const u of s){const{statisticType:c}=u,d=c!=="exceedslimit"?u.onStatisticField:void 0;if(!n.has(d)){const f=[];for(const m of t){const x=this._getAttributeValues(e,m,this.items,r);f.push(x)}n.set(d,this._calculateUniqueValues(f,this.items,e.returnDistinctValues))}const h=n.get(d);for(const f in h){const{data:m,items:x}=h[f],_=m.join(",");i&&!e.validateItems(x,i)||l.add(_)}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;ie(this.query.outSR)&&!B(t.spatialReference,this.query.outSR)?e.queryGeometry=W({spatialReference:this.query.outSR,...N(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=W({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,a=Ee(this.hasZ,this.hasM),{point:r,mode:n}=e,l=typeof e.distance=="number"?e.distance:e.distance.x,u=typeof e.distance=="number"?e.distance:e.distance.y,c={candidates:[]},d=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",f=this._getPointCreator(n,t,this.spatialReference,i),m=new Be(null,0),x=new Be(null,0),_={x:0,y:0,z:0};for(const F of this.items){const T=s.getGeometry(F);if(T==null)continue;const{coords:S}=T,R=T.isPoint?Lt:T.lengths;if(m.coords=S,x.coords=S,e.returnEdge){let w=0;for(let I=0;I<R.length;I++){const y=R[I],p=w;for(let g=0;g<y;g++,w+=a){if(!d&&g===y-1)continue;const v=m;v.coordsIndex=w;const b=x;b.coordsIndex=g===y-1?p:w+a;const E=_;if(!Ut(_,r,v,b))continue;const q=(r.x-E.x)/l,Q=(r.y-E.y)/u,$=q*q+Q*Q;$<=1&&c.candidates.push(new Bt(s.getObjectId(F),f(E),Math.sqrt($),f(v),f(b)))}}}if(e.vertexMode==="all"){let w=0;for(let I=0;I<R.length;I++){const y=R[I],p=w,g=x;g.coordsIndex=p;for(let v=0;v<y;v++,w+=a){const b=m;if(b.coordsIndex=w,d&&v===y-1&&b.x===g.x&&b.y===g.y)continue;const E=(r.x-b.x)/l,q=(r.y-b.y)/u,Q=E*E+q*q;Q<=1&&c.candidates.push(new Ve(s.getObjectId(F),f(b),Math.sqrt(Q)))}}}else if(h&&e.vertexMode==="ends"){let w=0;const I=[];for(let y=0;y<R.length;y++){I.push(w);const p=R[y];w+=p*a,!d&&p>1&&I.push(w-a)}for(const y of I){const p=m;p.coordsIndex=y;const g=(r.x-p.x)/l,v=(r.y-p.y)/u,b=g*g+v*v;b<=1&&c.candidates.push(new Ve(s.getObjectId(F),f(p),Math.sqrt(b)))}}}return c.candidates.sort((F,T)=>F.distance-T.distance),c}_getPointCreator(e,t,i,s){const a=s==null||B(i,s)?l=>l:l=>N(l,i,s),{hasZ:r}=this,n=0;return e==="3d"?r&&t?({x:l,y:u,z:c})=>a({x:l,y:u,z:c}):({x:l,y:u})=>a({x:l,y:u,z:n}):({x:l,y:u})=>a({x:l,y:u})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:l,scale:u,timeZone:c,outStatisticTypes:d}=e,h=this.fieldsIndex.get(t),f=xe(h)||ue(h)||ce(h),m=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:u,timeZone:c},this.items),x=St({normalizationType:a,normalizationField:s,minValue:n,maxValue:l}),_={value:.5,fieldType:h==null?void 0:h.type},F=ae(h)?ve({values:m,supportsNullCount:x,percentileParams:_,outStatisticTypes:d}):Ae({values:m,minValue:n,maxValue:l,useSampleStdDev:!a,supportsNullCount:x,percentileParams:_,outStatisticTypes:d});return Tt(F,d,f)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:n}=e,l=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:n},this.items,!1),u=Rt(l);return bt(u,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d,scale:h,timeZone:f}=e,m=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:f},this.items),x=vt(m,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d});return At(x,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d,scale:h,timeZone:f}=e,m=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:f},this.items);return Qt(m,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&(t!=null&&t.length))for(const s of t.slice().reverse()){const a=s.split(" "),r=a[0],n=this.fieldsIndex.get(r),l=!!a[1]&&a[1].toLowerCase()==="desc",u=Vt(n==null?void 0:n.type,l,"case-sensitive");e.sort((c,d)=>{const h=i(c,r,n),f=i(d,r,n);return u(h,f)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:n}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:f,returnM:m}=e,x=d!=null&&t.length>(h||0)+d,_=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(F=>this.fieldsIndex.get(F)));return{exceededTransferLimit:x,features:this._createFeatures(e,t),fields:_,geometryType:i,hasM:s&&m,hasZ:a&&f,objectIdFieldName:r,spatialReference:W(u||n),transform:c&&be(c)||null}}_createFeatures(e,t){const i=new J(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:d,resultRecordCount:h,returnZ:f=!1,returnM:m=!1}=e,x=a&&f,_=s&&m;let F=[],T=0;const S=[...t];if(this._sortFeatures(S,r,(w,I,y)=>i.getFieldValue(w,I,y)),this.geometryType&&(l||u)){const w=be(n)??void 0,I=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(l&&!u)for(const y of S){const p=this.featureAdapter.getGeometry(y),g=this._addFeatureJSONMetadata(y,{attributes:i.getAttributes(y),geometry:Y(this.geometryType,p,c,w,x,_)});I&&p&&!g.geometry&&(g.centroid=ne(this,this.featureAdapter.getCentroid(y,this),w)),F[T++]=g}else if(!l&&u)for(const y of S)F[T++]=this._addFeatureJSONMetadata(y,{attributes:i.getAttributes(y),centroid:ne(this,this.featureAdapter.getCentroid(y,this),w)});else for(const y of S)F[T++]=this._addFeatureJSONMetadata(y,{attributes:i.getAttributes(y),centroid:ne(this,this.featureAdapter.getCentroid(y,this),w),geometry:Y(this.geometryType,this.featureAdapter.getGeometry(y),c,w,x,_)})}else for(const w of S){const I=i.getAttributes(w);I&&(F[T++]=this._addFeatureJSONMetadata(w,{attributes:I}))}const R=d||0;if(h!=null){const w=R+h;F=F.slice(R,Math.min(F.length,w))}return F}_addFeatureJSONMetadata(e,t){var s,a;const i=(a=(s=this.featureAdapter).getMetadata)==null?void 0:a.call(s,e);return i!==void 0&&(t.metadata=i),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if(a.statisticType==="exceedslimit"){t=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,s=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{const a=Ee(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((n,l)=>{const u=r.getGeometry(l);return n+(u!=null&&u.coords.length||0)},0)/a>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){var R;const s=[],a=new Map,r=new Map,n=new Map,l=new Map,u=new J(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:d,having:h,orderByFields:f,resultRecordCount:m}=e,x=d==null?void 0:d.length,_=!!x,F=_?d[0]:null,T=_&&!this.fieldsIndex.get(F);for(const w of c??[]){const{outStatisticFieldName:I,statisticType:y}=w,p=w,g=y!=="exceedslimit"?w.onStatisticField:void 0,v=y==="percentile_disc"||y==="percentile_cont",b=y==="EnvelopeAggregate"||y==="CentroidAggregate"||y==="ConvexHullAggregate",E=_&&x===1&&(g===F||T)&&y==="count";if(_){if(!n.has(g)){const K=[];for(const se of d){const ee=this._getAttributeValues(u,se,t,a);K.push(ee)}n.set(g,this._calculateUniqueValues(K,t,!b&&u.returnDistinctValues))}const Q=n.get(g);if(!Q)continue;const $=Object.keys(Q);for(const K of $){const{count:se,data:ee,items:me,itemPositions:Ze}=Q[K],ye=ee.join(",");if(!h||u.validateItems(me,h)){const Z=l.get(ye)||{attributes:{}};if(b){Z.aggregateGeometries||(Z.aggregateGeometries={});const{aggregateGeometries:M,outStatisticFieldName:k}=await this._getAggregateGeometry(p,me);Z.aggregateGeometries[k]=M}else{let M=null;if(E)M=se;else{const k=this._getAttributeValues(u,g,t,a),pe=Ze.map(ke=>k[ke]);M=v&&"statisticParameters"in p?this._getPercentileValue(p,pe):this._getStatisticValue(p,pe,null,u.returnDistinctValues)}Z.attributes[I]=M}let je=0;d.forEach((M,k)=>Z.attributes[this.fieldsIndex.get(M)?M:"EXPR_"+ ++je]=ee[k]),l.set(ye,Z)}}}else if(b){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:Q,outStatisticFieldName:$}=await this._getAggregateGeometry(p,t);i.aggregateGeometries[$]=Q}else{const Q=this._getAttributeValues(u,g,t,a);i.attributes[I]=v&&"statisticParameters"in p?this._getPercentileValue(p,Q):this._getStatisticValue(p,Q,r,u.returnDistinctValues)}const q=y!=="min"&&y!=="max"||!ae(this.fieldsIndex.get(g))&&!this._isAnyDateField(g)?null:(R=this.fieldsIndex.get(g))==null?void 0:R.type;s.push({name:I,alias:I,type:q||"esriFieldTypeDouble"})}const S=_?Array.from(l.values()):[i];return this._sortFeatures(S,f,(w,I)=>w.attributes[I]),m&&(S.length=Math.min(m,S.length)),{fields:s,features:S}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return xe(t)||ue(t)||ce(t)||U(t)}async _getAggregateGeometry(e,t){const{convexHull:i,union:s}=await He(()=>import("./geometryEngineJSON-3ft81lFk.js"),__vite__mapDeps([0,1,2]),import.meta.url),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:n,spatialReference:l,geometryType:u}=this,c=t.map(f=>Y(u,n.getGeometry(f))),d=i(l,c,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const f=d?Je(d):_e(s(l,c));h.aggregateGeometries={...f,spatialReference:l},h.outStatisticFieldName=r||"extent"}else if(a==="CentroidAggregate"){const f=d?Ue(d):Le(_e(s(l,c)));h.aggregateGeometries={x:f[0],y:f[1],spatialReference:l},h.outStatisticFieldName=r||"centroid"}else a==="ConvexHullAggregate"&&(h.aggregateGeometries=d,h.outStatisticFieldName=r||"convexHull");return h}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;return n=i!=null&&i.has(a)?i.get(a):ae(this.fieldsIndex.get(a))||this._isAnyDateField(a)?ve({values:t,returnDistinct:s}):Ae({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n),n[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,l=this.fieldsIndex.get(i);return zt(t,{value:r,orderBy:n,fieldType:l==null?void 0:l.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),r=i.map(n=>e.getFieldValue(n,t,a));return s.set(t,r),r}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let r=0;r<a;r++){const n=t[r],l=[];for(const c of e)l.push(c[r]);const u=l.join(",");s[u]==null?s[u]={count:1,data:l,items:[n],itemPositions:[r]}:(i||s[u].count++,s[u].items.push(n),s[u].itemPositions.push(r))}return s}async _getDataValues(e,t,i=!0){const s=new J(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:r,timeZone:n}=e;return a?s.getExpressionValues(t,a,{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},n):s.getDataValues(t,L(e),i)}_calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];const s=t.intervals,a=t.min??0,r=t.max??0,n=s.map(([l,u])=>({minValue:l,maxValue:u,count:0,items:[]}));for(let l=0;l<e.length;l++){const u=e[l],c=i[l];if(u!=null&&u>=a&&u<=r){const d=Et(s,u);d>-1&&(n[d].count++,n[d].items.push(c))}}return n}async createQueryBinsResponse(e){var f;const t=(f=e.bin)==null?void 0:f.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,r=[],n=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:j,alias:j,type:"esriFieldTypeInteger"}],l=new J(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],(m,x,_)=>l.getFieldValue(m,x,_));const d=this._getAttributeValues(l,i,c,u),h=this._calculateUniqueValues([d],c,l.returnDistinctValues);for(const m in h){const{items:x}=h[m],_=await this._createBinsResponse(e,x);if(r.push(..._.features.map(F=>({...F,attributes:{...F.attributes,[s??i]:m}}))),_.fields)for(const F of _.fields)n.some(T=>T.name===F.name)||n.push(F)}return{fields:n,features:r}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(Gt.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(qt.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(Dt.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(Mt.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){var m;const{field:s,normalizationField:a,numBins:r,normalizationType:n,normalizationTotal:l,start:u,end:c}=e,d=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:(m=t.outTimeReference)==null?void 0:m.ianaTimeZone},i),h=Qe(d,{field:s,normalizationField:a,normalizationType:n,normalizationTotal:l,numBins:r,minValue:G(u,!1),maxValue:G(c,!1)}),f=this._calculateHistogramBins(d,h,i);return this._createFeaturesFromHistogramBins(f,t)}async _createDateBinsResponse(e,t,i){var S,R;const{field:s,interval:a,start:r,end:n,snapToData:l,returnFullIntervalBin:u}=e,c=a.unit,d=await this._getDataValues({field:e.field,timeZone:(S=t.outTimeReference)==null?void 0:S.ianaTimeZone},i),h=U(this.fieldsIndex.get(s)),f=Ct.toJSON(c),m=d.filter(Boolean).sort((w,I)=>w-I),x=r!=null?G(r,h):m[0],_=n!=null?G(n,h):m[m.length-1],F=[];if(x!=null&&_!=null){const w={zone:((R=t.outTimeReference)==null?void 0:R.ianaTimeZone)??Ye},I=te.fromMillis(x,w),y=te.fromMillis(_,w);if(l==="last"){let p=y;for(;p>I;){const g=p.minus({[f]:a.value});if(g<I){F.unshift([u?g.toMillis():I.toMillis(),p.toMillis()]);break}F.unshift([g.toMillis(),p.toMillis()]),p=g}}else{let p=l==="first"?I:I.startOf(f);for(;p<=y;){const g=p.plus({[f]:a.value});if(g>y){F.push([p.toMillis(),u?g.toMillis():y.toMillis()]);break}F.push([p.toMillis(),g.toMillis()]),p=g}}}const T=this._calculateHistogramBins(d,{intervals:F,min:x,max:_},i);return this._createFeaturesFromHistogramBins(T,t)}async _createFixedBoundariesBinsResponse(e,t,i){var d;const{field:s}=e,a=await this._getDataValues({field:s,timeZone:(d=t.outTimeReference)==null?void 0:d.ianaTimeZone},i),r=U(this.fieldsIndex.get(s)),n=e.boundaries.map(h=>G(h,r)).sort((h,f)=>h-f),l=[];for(let h=0;h<n.length-1;h++)l.push([n[h],n[h+1]]);const u={intervals:l,min:n.at(0),max:n.at(-1)},c=this._calculateHistogramBins(a,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,i){var h;const{field:s,interval:a,start:r,end:n}=e,l=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:(h=t.outTimeReference)==null?void 0:h.ianaTimeZone},i),u=U(this.fieldsIndex.get(s)),c=Qe(l,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:G(r,u),maxValue:G(n,u)},!0),d=this._calculateHistogramBins(l,c,i);return this._createFeaturesFromHistogramBins(d,t)}async _createFeaturesFromHistogramBins(e,t){var m,x,_,F,T,S;const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",n=[],l=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],u=(x=(m=t.bin)==null?void 0:m.stackBy)==null?void 0:x.value,c=(F=(_=t.bin)==null?void 0:_.stackBy)==null?void 0:F.outAlias;u&&l.push({name:j,alias:j,type:"esriFieldTypeInteger"},{name:c??u,alias:c??u,type:"esriFieldTypeString"});let d=0;const h=t.bin.type==="dateBin",f=(T=t.outTimeReference)==null?void 0:T.ianaTimeZone;for(const R of e){const{minValue:w,maxValue:I,items:y}=R,p={attributes:{}};let g;if(p.attributes[a]=h&&f&&w!=null?te.fromMillis(w,{zone:f}).toISO():w,p.attributes[r]=h&&f&&I!=null?te.fromMillis(I,{zone:f}).toISO():I,u?(g=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[u],orderByFields:[u]},y),p.attributes[j]=++d,t.bin.jsonStyle==="flat"?n.push(...g.features.map(({attributes:{EXPR_1:v,...b},...E})=>({...E,attributes:c??v?{...b,[c??v]:v,...p.attributes}:{...b,...p.attributes}}))):(p.stackedAttributes=g.features.map(({attributes:{EXPR_1:v,...b}})=>c??v?{...b,[c??v]:v}:b),n.push(p))):((S=t.bin)!=null&&S.splitBy&&(p.attributes[j]=++d),g=await this._createStatisticsQueryResponse(t,y,p),n.push(p)),g.fields)for(const v of g.fields)l.some(b=>b.name===v.name)||l.push(v)}return t.binOrder==="desc"&&n.reverse(),{fields:l,features:n}}}function Ut(o,e,t,i){const s=i.x-t.x,a=i.y-t.y,r=e.x-t.x,n=e.y-t.y,l=s*s+a*a;if(l===0)return!1;const u=r*s+n*a,c=Math.min(1,Math.max(0,u/l));return o.x=t.x+s*c,o.y=t.y+a*c,!0}function Ee(o,e){return o?e?4:3:e?3:2}class Be{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const Lt=[1],P="unsupported-query";async function Yt(o,e){var i;const t=o.bin;if(!t.onField&&!((i=t.onExpression)!=null&&i.value)||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new z(P,"Unsupported query options",{query:o});return de(o,e)}async function de(o,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:s}){if(o.geometryPrecision!=null||o.multipatchOption&&o.multipatchOption!=="xyFootprint"||o.pixelSize||o.relationParam||o.text)throw new z(P,"Unsupported query options",{query:o});return $e(e,s,o),Xt(e,s,o),Promise.all([De(o,t,i),he(i,o.outSR)]).then(()=>o)}function $e(o,e,t){var r;const{returnDistinctValues:i,outStatistics:s}=t,a=s?s.map(n=>n.outStatisticFieldName&&n.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const n=" asc",l=" desc",u=t.orderByFields.map(c=>{const d=c.toLowerCase();return d.includes(n)?d.split(n)[0]:d.includes(l)?d.split(l)[0]:c}).filter(c=>!a.includes(c));D(o,e,u,{expressionName:"orderByFields",query:t})}if("outFields"in t){if((r=t.outFields)!=null&&r.length)D(o,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new z(P,"outFields should be specified for returnDistinctValues",{query:t})}Ot(o,e,t.where,t)}const Wt=new Set([...Ne,...Oe]);function Xt(o,e,t){const{outStatistics:i,groupByFieldsForStatistics:s,having:a}=t,r=s==null?void 0:s.length,n=i==null?void 0:i.length;if(a){if(!r||!n)throw new z(P,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});Pt(o,e,a,i,t)}if(n){if(!ti(i))return;const l=i.map(u=>u.onStatisticField).filter(Boolean);D(o,e,l,{expressionName:"onStatisticFields",query:t}),r&&D(o,e,s,{expressionName:"groupByFieldsForStatistics",query:t});for(const u of i){const{onStatisticField:c,statisticType:d}=u;if((d==="percentile_disc"||d==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:h}=u;if(!h)throw new z(P,"statisticParameters should be set for percentile type",{definition:u,query:t})}else o.get(c)&&d!=="count"&&d!=="min"&&d!=="max"&&D(o,e,[c],{expressionName:`outStatistics with '${d}' statistic type`,allowedFieldTypes:Wt,query:t})}}}async function Kt(o,e,{fieldsIndex:t,geometryType:i,spatialReference:s,availableFields:a}){if(o.geometryPrecision!=null||o.multipatchOption||o.pixelSize||o.relationParam||o.text||o.outStatistics||o.groupByFieldsForStatistics||o.having||o.orderByFields)throw new z(P,"Unsupported query options",{query:o});return $e(t,a,o),Promise.all([ei(t,a,e,o),De(o,i,s),he(s,o.outSR)]).then(()=>o)}async function ei(o,e,t,i){let s=[];if(t.valueExpression){const{arcadeUtils:a}=await Me();s=a.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.field2&&s.push(t.field2),t.field3&&s.push(t.field3),t.normalizationField&&s.push(t.normalizationField),!s.length&&!t.valueExpression)throw new z(P,"field or valueExpression is required",{params:t});D(o,e,s,{expressionName:"statistics",query:i})}function ti(o){return o!=null&&o.every(e=>e.statisticType!=="exceedslimit")}const ii="unsupported-query";class pi{constructor(e){this._changeHandle=null,this.capabilities={query:Ft},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new kt,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=We(e.fieldsIndex)?e.fieldsIndex:Xe.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>{var i;return(i=this.fieldsIndex.get(t))==null?void 0:i.name}).filter(t=>t!=null)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=Ke}destroy(){this._changeHandle=Fe(this._changeHandle),this._frameTask=Fe(this._frameTask),this._clearCache(),et(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),i)}async executeQueryForCount(e={},t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),i)}async executeQueryForExtent(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),i)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),i)}async executeQueryForLatestObservations(e,t){var s;const i=V(t);if(!((s=this.timeInfo)!=null&&s.trackIdField))throw new z(ii,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),i)}async executeQueryForOpaqueFeatures(e,t){const i=V(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),i)).items}async executeAttributeBinsQuery(e,t){const i=V(t);return e=L(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),i)}async executeQueryForSummaryStatistics(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),s)}async executeQueryForUniqueValues(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),s)}async executeQueryForClassBreaks(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),s)}async executeQueryForHistogram(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),s)}async executeQueryForSnapping(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,i),i)}async fetchRecomputedExtents(e){const t=V(e);this._timeExtentPromise||(this._timeExtentPromise=yt(this.timeInfo,this.featureStore));const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return tt(t),{fullExtent:i,timeExtent:s}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==C)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==C)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const i=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const s=i.size;if(!s)return{count:0,extent:null};const a=await this._getBounds(i.items,i.spatialReference,t??this.spatialReference);return yield,{count:s,extent:a}}catch(i){if(i===C)return{count:0,extent:null};throw i}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=t.items,s=new Set;for(const a of i)s.add(t.featureAdapter.getObjectId(a));return s}catch(t){if(t===C)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==C)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await gt(e,this.definitionExpression,this.spatialReference),yield,e=await Yt(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,i),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(i){if(i!==C)throw i;t=new A([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:i,field2:s,field3:a,valueExpression:r}=t,n=yield*this._executeQueryForStatistics(e,{field:i,field2:s,field3:a,valueExpression:r});return yield,await n.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:i,distance:s,returnEdge:a,vertexMode:r}=e;if(!a&&r==="none")return{candidates:[]};let n=L(e.query);n=await xt(n,this.definitionExpression,this.spatialReference),yield,n=await de(n,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const l=!B(i.spatialReference,this.spatialReference);l&&(await he(i.spatialReference,this.spatialReference),yield);const u=typeof s=="number"?s:s.x,c=typeof s=="number"?s:s.y,d={xmin:i.x-u,xmax:i.x+u,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},h=l?N(d,this.spatialReference):d;if(!h)return{candidates:[]};const f=(await we(Ie(i),null,{signal:t}))[0];yield;const m=(await we(Ie(h),null,{signal:t}))[0];if(yield,f==null||m==null)return{candidates:[]};const x=await this._searchFeatures(oe(m.toJSON()));yield;const _=new A(x,n,this);this._executeObjectIdsQuery(_),yield,this._executeTimeQuery(_),yield,this._executeAttributesQuery(_),yield,yield*this._executeGeometryQueryForSnapping(_),yield;const F=f.toJSON(),T=l?N(F,this.spatialReference):F,S=l?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return _.createSnappingResponse({...e,point:T,distance:S},n.returnZ,i.spatialReference)}async _getBounds(e,t,i){const s=it(at(),st);return await this.featureStore.forEachBounds(e,a=>rt(s,a)),si(s,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(s=>i.push(s)))().then(()=>Se(i))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=L(e),e=await Re(e,this.definitionExpression,this.spatialReference),yield,e=await de(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),s}async*_executeSceneFilterQuery(e){if(e.sceneFilter==null)return null;const{outSR:t,returnGeometry:i,returnCentroid:s}=e,a=this.featureStore.featureSpatialReference,r=e.sceneFilter.geometry,n=a==null||B(a,r.spatialReference)?r:N(r,a);if(!n)return null;const l=i||s,u=ie(t)&&!B(this.spatialReference,t)&&l?async m=>this._project(m,t):m=>m;yield;const c=this.featureAdapter,d=await this._searchFeatures(oe(n));if(yield,e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const m=new Set;for(const R of d)m.add(c.getObjectId(R));const x=await this._getAllFeatures();yield;const _=await H("esriSpatialRelDisjoint",n,this.geometryType);yield;const F=R=>!m.has(c.getObjectId(R))||_(c.getGeometry(R)),T=yield*this._runSpatialFilter(x,F);yield;const S=new A(T,e,this);return await u(S)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(n,e))return await u(new A(d,e,this));const h=await H("esriSpatialRelContains",n,this.geometryType);yield;const f=yield*this._runSpatialFilter(d,m=>h(c.getGeometry(m)));return yield,await u(new A(f,e,this))}async*_executeGeometryQuery(e,t){if(t!=null&&t.items.length===0)return t;const{geometry:i,outSR:s,returnGeometry:a,returnCentroid:r}=e,n=t?null:this._getCacheKey(e),l=n?this._cache.get(n):null;if(l)return new A(l,e,this);const u=ie(s)&&!B(this.spatialReference,s),c=a||r,d=async S=>(u&&c&&await this._project(S,s),n&&this._cache.put(n,S.items),S),h=this.featureStore.featureSpatialReference,f=!i||h==null||B(h,i.spatialReference)?i:N(i,h);if(!f)return await d(t??await this._getAllFeaturesQueryEngineResult(e));yield;const m=this.featureAdapter;let x=await this._searchFeatures(oe(i));yield;const _=e.spatialRel??"esriSpatialRelIntersects";if(_==="esriSpatialRelDisjoint"){if(!x.length)return await d(t??await this._getAllFeaturesQueryEngineResult(e));const S=new Set;for(const g of x)S.add(m.getObjectId(g));let R;t!=null?R=t.items:(yield,R=await this._getAllFeatures(),yield);const w=await H(_,f,this.geometryType);yield;const I=g=>!S.has(m.getObjectId(g))||w(m.getGeometry(g)),y=yield*this._runSpatialFilter(R,I);yield;const p=new A(y,e,this);return await d(p)}if(t!=null){const S=new ht;x=x.filter(R=>nt(t.items,R,t.items.length,S)>=0)}if(!x.length){const S=new A([],e,this);return n&&this._cache.put(n,S.items),S}if(this._canExecuteSinglePass(f,e))return await d(new A(x,e,this));const F=await H(_,f,this.geometryType);yield;const T=yield*this._runSpatialFilter(x,S=>F(m.getGeometry(S)));return yield,await d(new A(T,e,this))}_executeAggregateIdsQuery(e){var s;if(e.items.length===0||!((s=e.query.aggregateIds)!=null&&s.length)||this.aggregateAdapter==null)return;const t=new Set;for(const a of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(a).forEach(r=>t.add(r));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(a=>t.has(i(a)))}_executeObjectIdsQuery(e){var s;if(e.items.length===0||!((s=e.query.objectIds)!=null&&s.length))return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(a=>t.has(i(a)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=pt(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=O(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){var l;const{query:t}=e,{spatialRel:i}=t;if(!((l=e==null?void 0:e.items)!=null&&l.length)||!t.geometry||!i)return;const s=await H(i,t.geometry,this.geometryType);yield;const a=this.featureAdapter,r=u=>s(a.getGeometry(u)),n=yield*this._runSpatialFilter(e.items,r);e.items=n}*_runSpatialFilter(e,t){if(!t)return e;if(this._frameTask==null)return e.filter(a=>t(a));let i=yield;const s=new Array;for(const a of e)t(a)&&s.push(a),i.madeProgress(),i.done&&(i=yield);return s}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,a=s||i,r=new Map,n=this.featureAdapter.getAttribute;for(const l of e.items){const u=n(l,t),c=n(l,a),d=r.get(u);(!d||c>n(d,a))&&r.set(u,l)}e.items=Array.from(r.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:a,outSR:r,resultType:n,cacheHint:l}=e;if(n!=="tile"&&!l)return null;const u=s||a;return ie(r)&&!B(this.spatialReference,r)&&u?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return qe(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||B(this.spatialReference,t))return e;const i=this.featureAdapter,s=lt()?await this._getFullExtent():void 0,a=await _t(e.items.map(r=>Y(this.geometryType,i.getGeometry(r))),this.spatialReference,t,{areaOfInterestExtent:s});return e.items=Se(a.map((r,n)=>i.cloneWithGeometry(e.items[n],ft(r,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,a=>t.add(a))));const i=Array.from(t.values());return t.clear(),i}async*_executeQueryForStatistics(e,t){e=L(e);try{e=await Re(e,this.definitionExpression,this.spatialReference),yield,e=await Kt(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),yield,s}catch(i){if(i!==C)throw i;return new A([],e,this)}}get test(){}}function oe(o){if(qe(o)){if(ot(o))return[Te(Math.min(o.xmin,o.xmax),Math.min(o.ymin,o.ymax),Math.max(o.xmin,o.xmax),Math.max(o.ymin,o.ymax))];if(ut(o))return o.rings.map(e=>Te(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[ct(dt(),o)]}function si(o,e,t,i,s){const a={xmin:o[0],ymin:o[1],xmax:o[3],ymax:o[4],spatialReference:W(i)};s&&isFinite(o[2])&&isFinite(o[5])&&(a.zmin=o[2],a.zmax=o[5],a.hasZ=!0);const r=N(a,e,t);if(r.spatialReference=W(t),r.xmax-r.xmin===0){const n=re(r.spatialReference);r.xmin-=n,r.xmax+=n}if(r.ymax-r.ymin===0){const n=re(r.spatialReference);r.ymin-=n,r.ymax+=n}if(s&&r.zmin!=null&&r.zmax!=null&&r.zmax-r.zmin===0){const n=re(r.spatialReference);r.zmin-=n,r.zmax+=n}return r}export{A as E,pi as W,si as Y};

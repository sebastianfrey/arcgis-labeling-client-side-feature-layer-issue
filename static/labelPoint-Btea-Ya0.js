import{bT as Q,bU as U,is as K,bQ as st,bR as it,bS as ht,d7 as rt,bP as nt,a$ as V,it as ot,iu as at,iv as ut,du as E,iw as pt,ix as ct}from"./index-C_bK48d2.js";import{s as b}from"./OptimizedGeometry-KE6YknPZ.js";class W{static fromOptimized(t,e,i=1){return new tt().initialize(t,e,i)}static fromJSON(t){const[e,i]=X(t),h=Q(t),n=U(t);return new Z().initialize(e,i,h,n,1)}static fromOptimizedCIM(t,e,i=1){return new O().initialize(t,e,i)}static fromJSONCIM(t,e=1){const[i,h]=X(t),n=Q(t),o=U(t);return new j().initialize(i,h,n,o,e)}static fromFeatureSetReader(t){const e=t.readGeometryForDisplay(),i=t.geometryType;return e&&i?this.fromOptimized(e,i):null}static fromFeatureSetReaderCIM(t){const e=t.readGeometryForDisplay(),i=t.geometryType;return e&&i?this.fromOptimizedCIM(e,i):null}static createEmptyOptimized(t,e=!1,i=!1,h=1){return new O().initialize(new b([],[],e,i),t,h)}static createEmptyJSON(t,e=!1,i=!1){return new Z().initialize([],t,e,i,1)}static createEmptyOptimizedCIM(t,e=!1,i=!1,h=1){return new O().initialize(new b([],[],e,i),t,h)}static createEmptyJSONCIM(t,e=!1,i=!1,h=1){return new j().initialize([],t,e,i,h)}asJSON(){const t=K(this),{hasZ:e,hasM:i}=this;return this.geometryType==="esriGeometryEnvelope"?{xmin:t[0][0][0],ymin:t[0][0][1],xmax:t[0][2][0],ymax:t[0][2][1]}:this.geometryType==="esriGeometryMultipoint"?{points:t.flat(),hasZ:e,hasM:i}:this.geometryType==="esriGeometryPoint"?{x:t[0][0][0],y:t[0][0][1],z:e?t[0][0][2]:void 0,m:i?t[0][0][e?3:2]:void 0}:this.geometryType==="esriGeometryPolygon"?{rings:t,hasZ:e,hasM:i}:{paths:t,hasZ:e,hasM:i}}getCurrentRingArea(){if(this.pathSize<3)return 0;let t,e,i=0;if(this.seekPathStart(),!this.nextPoint())return 0;t=this.x,e=this.y;const h=t,n=e;for(;this.nextPoint();)i+=(t-this.x)*(e+this.y),t=this.x,e=this.y;return i+=(t-h)*(e+n),-.5*i}invertY(){this.yFactor*=-1}}let tt=class G extends W{constructor(){super(...arguments),this._end=-1}get hasZ(){var t;return(t=this._geometry)==null?void 0:t.hasZ}get hasM(){var t;return(t=this._geometry)==null?void 0:t.hasM}initialize(t,e,i){return this.geometryType=e,this._stride=t.stride,this._geometry=t,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=i,this}reset(){this.initialize(this._geometry,this.geometryType,this.yFactor)}seekPath(t){if(t>=0&&t<this.totalSize){if(this._pathIndex<t)for(;this._pathIndex<t&&this.nextPath(););else if(this._pathIndex>t)for(;this._pathIndex>t&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(t){const e=this._pathOffset+t*this._stride;return e>=0&&e<this._end&&(this._pointOffset=e,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){return!(this.pathIndex>=this.totalSize-1)&&(this._pathIndex>=0&&(this._pathOffset+=this._stride*this.pathSize),this._pathIndex++,this._pointOffset=this._pathOffset-this._stride,this._end=this._pointOffset+this._stride+this._stride*this.pathSize,!0)}prevPath(){return!(this.pathIndex<=0)&&(this._pathIndex--,this._end=this._pathOffset,this._pathOffset-=this._stride*this.pathSize,this._pointOffset=this._pathOffset-this._stride,!0)}getCurrentPath(){const t=this._end,e=this._geometry.coords,i=this._pathOffset;return new G().initialize(new b([this.pathSize],e.slice(i,t),this.hasZ,this.hasM),this.geometryType,this.yFactor)}pathLength(){const t=this._end,e=this._stride,i=this._geometry.coords;let h=0;for(let n=this._pathOffset+e;n<t;n+=e){const o=i[n-e],r=i[n-e+1],a=i[n]-o,p=i[n+1]-r;h+=Math.sqrt(a*a+p*p)}return h}startPath(){this._geometry.lengths.push(0)}pushPath(t){this.startPath(),this.pushPoints(t)}pushPoint(t){for(let e=0;e<this._stride;++e)this._geometry.coords.push(t[e]);this._geometry.lengths[this.totalSize-1]++}pushXY(t,e){this._geometry.coords.push(t,e),this._geometry.lengths[this.totalSize-1]++}pushPoints(t){for(const e of t)for(let i=0;i<this._stride;++i)this._geometry.coords.push(e[i]);this._geometry.lengths[this.totalSize-1]+=t.length}pushCursor(t){const e=t.asOptimized();this._geometry.coords.push(...e.coords),this._geometry.lengths.push(...e.lengths)}asOptimized(){const t=this._geometry.clone();if(this.yFactor!==1)for(let e=1;e<t.coords.length;e+=this._stride)t.coords[e]*=this.yFactor;return this.geometryType==="esriGeometryPoint"&&(t.lengths.length=0),t}isClosed(){const t=this._geometry.coords,e=this._pathOffset,i=this._end-this._stride;for(let h=0;h<this._stride;h++)if(t[e+h]!==t[i+h])return!1;return!0}clone(){return new G().initialize(this._geometry.clone(),this.geometryType,this.yFactor)}get totalPoints(){return this._geometry.isPoint?1:this._geometry.lengths.reduce((t,e)=>t+e)}get pathSize(){const{lengths:t}=this._geometry;return this._geometry.isPoint?1:this._pathIndex<0||this._pathIndex>t.length-1?0:t[this._pathIndex]}get totalSize(){return this._geometry.isPoint?1:this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(t){this._geometry.coords[this._pointOffset]=t}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(t){this._geometry.coords[this._pointOffset+1]=this.yFactor*t}get z(){return this._geometry.coords[this._pointOffset+2]}set z(t){this._geometry.coords[this._pointOffset+2]=t}get m(){const t=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+t]}set m(t){this._geometry.coords[this._pointOffset+3]=t}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}};function _t(s){const t=[s.x,s.y];return s.z&&t.push(s.z),s.m&&t.push(s.m),t}function X(s){return st(s)?[s.rings,"esriGeometryPolygon"]:it(s)?[s.paths,"esriGeometryPolyline"]:ht(s)?[[s.points],"esriGeometryMultipoint"]:rt(s)?[[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]],"esriGeometryEnvelope"]:nt(s)?[[[_t(s)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}let Z=class v extends W{initialize(t,e,i,h,n){return this._paths=t,this.geometryType=e,this.hasZ=i,this.hasM=h,this._pathIndex=this._pointIndex=-1,this.yFactor=n,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(t){return this._pathIndex=t,this._pointIndex=-1,t>=0&&t<this.totalSize&&(this._currentPath=this._paths[t],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(t){return t>=0&&t<this._currentPath.length&&(this._pointIndex=t,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this.pathIndex>0&&(this._pointIndex=-1,this._pathIndex--,this._currentPath=this._paths[this._pathIndex],!0)}pathLength(){const t=this._currentPath.length,e=this._currentPath;let i=0;for(let h=1;h<t;h++){const n=e[h-1],o=e[h],r=n[0],a=n[1],p=o[0]-r,c=o[1]-a;i+=Math.sqrt(p*p+c*c)}return i}startPath(){this._paths.push([])}getCurrentPath(){return new v().initialize([this._currentPath],this.geometryType,this.hasZ,this.hasM,this.yFactor)}pushPath(t){this._paths.push(t)}pushPoint(t){this._paths[this.totalSize-1].push(t)}pushXY(t,e){this._paths[this.totalSize-1].push([t,e])}pushPoints(t){this._paths[this.totalSize-1].push(...t)}pushCursor(t){const e=K(t);for(const i of e)this.pushPath(i)}asOptimized(){const{hasZ:t,hasM:e}=this,i=new b([],[],t,e),{coords:h,lengths:n}=i;if(this.geometryType==="esriGeometryPoint")h.push(...this._paths[0][0]),n.length=0;else for(const o of this._paths){for(const r of o)h.push(r[0]),h.push(r[1]*this.yFactor),t&&h.push(r[2]),e&&h.push(r[this._mIndex]);n.push(o.length)}return i}isClosed(){const t=this._currentPath[0],e=this._currentPath[this._currentPath.length-1];for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}clone(){return new v().initialize(V(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map(t=>t.length).reduce((t,e)=>t+e)}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(t){this._currentPoint[0]=t}get y(){return this.yFactor*this._currentPoint[1]}set y(t){this._currentPoint[1]=this.yFactor*t}get z(){return this._currentPoint[2]}set z(t){this._currentPoint[2]=t}get m(){return this._currentPoint[this._mIndex]}set m(t){this._currentPoint[this._mIndex]=t}get pathIndex(){return this._pathIndex}};const M=4,w=1;class O extends tt{initialize(t,e,i){return super.initialize(t,e,i),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map(h=>new Set)),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const t=new O().initialize(this._geometry.clone(),this.geometryType,this.yFactor);return t._controlPoints=this._controlPoints,t}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(t){this._controlPoints[this.pathIndex].add(t)}getControlPointAt(t){return this._controlPoints[this.pathIndex].has(t)}}let j=class et extends Z{initialize(t,e,i,h,n){return super.initialize(t,e,i,h,n)}clone(){return new et().initialize(V(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][M]=w}getControlPoint(){return this._paths[this.pathIndex][this._pointIndex][M]===w}setControlPointAt(t){this._paths[this.pathIndex][t][M]=w}getControlPointAt(t){return this._paths[this.pathIndex][t][M]===w}};const lt=100*222045e-21;function xt(s){if(s.totalSize===0)return null;const t=ot(s);if(!t)return null;const e=4*(Math.abs(t[0])+Math.abs(t[2])+Math.abs(t[1])+Math.abs(t[3])+1)*lt;let i=0,h=0;s.reset();for(let m=0;s.nextPath();m++){const g=s.getCurrentRingArea();g>h&&(h=g,i=m)}if(s.seekPath(i),s.pathSize===0)return null;s.seekPathStart();const n=at(s);if(Math.abs(h)<=2*e*e)return[(n[0]+n[2])/2,(n[1]+n[3])/2];s.seekPathStart();const o=ut(s,E());if(o===null)return null;if(s.totalPoints<4)return o;const r=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],a=[NaN,NaN,NaN,NaN],p=[NaN,NaN,NaN,NaN];let c=!1,u=z(o,s,!0);u.distance===0&&(c=!0,r[0][0]=o[0],r[0][1]=o[1],u=z(o,s,!1)),a[0]=u.distance,p[0]=0;const f=[NaN,NaN];let l=!1,y=.25,d=-1,_=NaN;do if(_=NaN,r[1]=k(s,T(n[0],n[2],y),e,t),isNaN(r[1][0])||isNaN(r[1][1])||(u=z(r[1],s,!1),_=u.distance),!isNaN(_)&&_>e&&F(r[1],s))l=!0,a[1]=_,p[1]=N(r[1],o);else if(!isNaN(_)&&_>d&&(d=_,f[0]=r[1][0],f[1]=r[1][1]),y-=.01,y<.1){if(!(d>=0))break;l=!0,a[1]=d,r[1][0]=f[0],r[1][1]=f[1],p[1]=N(r[1],o)}while(!l);l=!1,y=.5,d=-1;let A=.01,R=1;do if(_=NaN,r[2]=k(s,T(n[0],n[2],y),e,t),isNaN(r[2][0])||isNaN(r[2][1])||(u=z(r[2],s,!1),_=u.distance),!isNaN(_)&&_>e&&F(r[2],s))l=!0,a[2]=_,p[2]=N(r[2],o);else if(!isNaN(_)&&_>d)d=_,f[0]=r[2][0],f[1]=r[2][1];else if(_>d&&(d=_,f[0]=r[2][0],f[1]=r[2][1]),y=.5+A*R,A+=.01,R*=-1,y<.3||y>.7){if(!(d>=0))break;l=!0,a[2]=d,r[2][0]=f[0],r[2][1]=f[1],p[2]=N(r[2],o)}while(!l);l=!1,y=.75,d=-1;do if(_=NaN,r[3]=k(s,T(n[0],n[2],y),e,t),isNaN(r[3][0])||isNaN(r[3][1])||(u=z(r[3],s,!1),_=u.distance),!isNaN(_)&&_>e&&F(r[3],s))l=!0,a[3]=_,p[3]=N(r[3],o);else if(_>d&&(d=_,f[0]=r[3][0],f[1]=r[3][1]),y+=.01,y>.9){if(!(d>=0))break;l=!0,a[3]=d,r[3][0]=f[0],r[3][1]=f[1],p[3]=N(r[3],o)}while(!l);const P=[0,1,2,3],S=c?0:1;let J;for(let m=S;m<4;m++)for(let g=S;g<3;g++){const Y=p[g],L=p[g+1];yt(Y,L)>0&&(J=P[g],P[g]=P[g+1],P[g+1]=J,p[g]=L,p[g+1]=Y)}let q=S,D=0,I=0;for(let m=S;m<4;m++){switch(m){case 0:I=2*a[P[m]];break;case 1:I=1.66666666*a[P[m]];break;case 2:I=1.33333333*a[P[m]];break;case 3:I=a[P[m]]}I>D&&(D=I,q=P[m])}return r[q]}function F(s,t){let e,i,h,n,o=0;for(t.reset();t.nextPath()&&t.nextPoint();)for(e=t.x,i=t.y;t.nextPoint();e=h,i=n)h=t.x,n=t.y,i>s[1]!=n>s[1]&&((h-e)*(s[1]-i)-(n-i)*(s[0]-e)>0?o++:o--);return o!==0}function z(s,t,e){if(e&&F(s,t))return{coord:s,distance:0};let i=1/0,h=0,n=0,o=[0,0],r=[0,0];const a=[0,0];for(t.reset();t.nextPath()&&t.nextPoint();)if(!(t.pathSize<2))for(o[0]=t.x,o[1]=t.y;t.nextPoint();o=r){r=[t.x,t.y],pt(a,s,o,r);const p=N(s,a);p<i&&(i=p,h=a[0],n=a[1])}return{coord:[h,n],distance:Math.sqrt(i)}}function k(s,t,e,i){const h=[t,0];let n=1/0,o=1/0,r=!1,a=!1;const p=[[t,i[1]-1],[t,i[3]+1]],c=[0,0],u=[0,0],f=[0,0],l=[[0,0],[0,0]],y=E();for(s.reset();s.nextPath()&&s.nextPoint();)if(!(s.pathSize<2))for(l[0][0]=s.x,l[0][1]=s.y;s.nextPoint();l[0][0]=l[1][0],l[0][1]=l[1][1]){if(l[1][0]=s.x,l[1][1]=s.y,dt(y,l)===null||(u[0]=p[0][0],u[1]=p[0][1],f[0]=p[1][0],f[1]=p[1][1],ft(y,u,f)===0)||!ct(p[0],p[1],l[0],l[1],c))continue;const d=c[1];n>o?d<n&&(n=d,r=!0):d<o&&(o=d,a=!0)}return r&&a?h[1]=(n+o)/2:h[0]=h[1]=NaN,h}function dt(s,t){if(t.length<2)return null;s||(s=E());const[e,i]=t[0],[h,n]=t[1];return s[0]=Math.min(e,h),s[1]=Math.min(i,n),s[2]=Math.max(e,h),s[3]=Math.max(i,n),s}const C=1,$=4,B=3,H=12;function ft(s,t,e){let i=x(t,s),h=x(e,s);const n=s[0],o=s[1],r=s[2],a=s[3];if(i&h)return 0;if(!(i|h))return 4;const p=(i?1:0)|(h?2:0);do{const c=e[0]-t[0],u=e[1]-t[1];if(c>u)i&B?(i&C?(t[1]+=u*(n-t[0])/c,t[0]=n):(t[1]+=u*(r-t[0])/c,t[0]=r),i=x(t,s)):h&B?(h&C?(e[1]+=u*(n-e[0])/c,e[0]=n):(e[1]+=u*(r-e[0])/c,e[0]=r),h=x(e,s)):i?(i&$?(t[0]+=c*(o-t[1])/u,t[1]=o):(t[0]+=c*(a-t[1])/u,t[1]=a),i=x(t,s)):(h&$?(e[0]+=c*(o-e[1])/u,e[1]=o):(e[0]+=c*(a-e[1])/u,e[1]=a),h=x(e,s));else if(i&H?(i&$?(t[0]+=c*(o-t[1])/u,t[1]=o):(t[0]+=c*(a-t[1])/u,t[1]=a),i=x(t,s)):h&H?(h&$?(e[0]+=c*(o-e[1])/u,e[1]=o):(e[0]+=c*(a-e[1])/u,e[1]=a),h=x(e,s)):i?(i&C?(t[1]+=u*(n-t[0])/c,t[0]=n):(t[1]+=u*(r-t[0])/c,t[0]=r),i=x(t,s)):(h&C?(e[1]+=u*(n-e[0])/c,e[0]=n):(e[1]+=u*(r-e[0])/c,e[0]=r),h=x(e,s)),i&h)return 0}while(i|h);return p}function x(s,t){return(s[0]<t[0]?1:0)|(s[0]>t[2]?1:0)<<1|(s[1]<t[1]?1:0)<<2|(s[1]>t[3]?1:0)<<3}function T(s,t,e){return s+(t-s)*e}function N(s,t){return(s[0]-t[0])*(s[0]-t[0])+(s[1]-t[1])*(s[1]-t[1])}function yt(s,t){if(s<t)return-1;if(s>t)return 1;if(s===t)return 0;const e=isNaN(s),i=isNaN(t);return e<i?-1:e>i?1:0}export{W as _,xt as l};

import{i as a}from"./memoryEstimations-w0EAmzVg.js";class c{constructor(s=[],t=[],o=!1,r=!1){this.lengths=s??[],this.coords=t??[],this.hasZ=o,this.hasM=r}static fromJSON({lengths:s,coords:t,hasZ:o,hasM:r}){return new c(s,t,o||!1,r||!1)}static fromRect([s,t,o,r]){const e=o-s,i=r-t;return new c([5],[s,t,e,0,0,i,-e,0,0,-i])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.isPoint?1:this.lengths.reduce((s,t)=>s+t,0)}get usedMemory(){return 64+a(this.lengths,this.coords)}get stride(){return 2+(this.hasZ?1:0)+(this.hasM?1:0)}area(){if(this.isPoint)return 0;let s=0,t=0;for(const o of this.lengths){if(o<3)continue;const{stride:r}=this;let e=this.coords[r*t],i=this.coords[r*t+1];for(let h=1;h<o;h+=1){const n=r*(t+h),d=this.coords[n],l=this.coords[n+1];s+=-.5*(d-e)*(l+i),e=d,i=l}t+=o}return s}forEachVertex(s){let t=0;if(this.isPoint)return s(this.coords[0],this.coords[1]);const{stride:o}=this;for(const r of this.lengths){for(let e=0;e<r;e++){const i=o*(t+e);s(this.coords[i],this.coords[i+1])}t+=r}}deltaDecode(){const s=this.clone(),{coords:t,lengths:o}=s;let r=0;const{stride:e}=this;for(const i of o){for(let h=1;h<i;h++){const n=e*(r+h);t[n]+=t[n-e],t[n+1]+=t[n+1-e]}r+=i}return s}clone(s){if(this.isPoint)return new c([],Array.from(this.coords.slice(0,this.stride)),this.hasZ,this.hasM);const t=Array.from(this.lengths),{stride:o,size:r}=this,e=this.coords.slice(0,r*o);return s?(s.set(e),new c(t,s)):new c(t,Array.from(e),this.hasZ,this.hasM)}justXY(){const{stride:s,size:t}=this;if(s===2)return this;const o=new Array(t*s);for(let r=0,e=0;r<o.length;r+=s)o[e++]=this.coords[r],o[e++]=this.coords[r+1];return new c(this.lengths,o,!1,!1)}}export{c as s};

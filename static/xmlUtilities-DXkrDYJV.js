const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./densifyOperator-BpEieVOf.js","./index-C_bK48d2.js","./index-DxLSJ8yk.css","./Point2D-CHGoJJR2.js","./ProjectionTransformation-yTMc8p-1.js","./Envelope2D-K-BIX8ba.js","./Transformation2D-CsY48lRi.js","./SimpleGeometryCursor-B92kdZ15.js","./OperatorDefinitions-DP7_WWTp.js","./jsonConverter-E47-BQ_b.js","./apiConverter-CdLHvLkb.js","./differenceOperator-D7538bjp.js","./lengthOperator-J6a_F19i.js"])))=>i.map(i=>d[i]);
import{aJ as I,aK as b,h2 as Ie,aL as oe,bb as Fe,ca as Y,mx as Re,aF as ne,a as $,dj as X,aM as P,ax as V,a7 as be,hw as Be,ae as we,cG as De,b0 as Ce,_ as Z,dl as He,hv as Je,c2 as ze,c9 as $e,dv as Me}from"./index-C_bK48d2.js";import{t as N,y as Se,C as Oe,s as Ne,a as Ee,n as ve,b as We,g as Le,v as ce,U as qe,D as Ae,c as Ge}from"./datasetUtils-Cmlo5xfm.js";import{u as je,g as ue,l as he,p as Ve,d as Ue,j as Qe,D as me,h as Xe,a as Ke,N as Ye,q as Ze,W as et,z as tt,B as de,b as it,s as fe}from"./RasterJobHandlerMixin-WvILX_c-.js";import{R as nt,p as rt,a as st,k as at,O as ot}from"./RasterSymbolizer-D_kc921t.js";import{QueueProcessor as lt}from"./QueueProcessor-7WLZ5z5V.js";import{i as ct,m as ut,h as ht,x as mt,s as dt}from"./RawBlockCache-CHGqbnWp.js";import{g as ft}from"./pixelRangeUtils-BjN-b_zG.js";import{S as te,O as _e,j as pt,u as yt,s as xt,l as gt}from"./vectorFieldUtils-rpoioFtp.js";import{$ as Q,j as re,W as pe,f as ye,c as It,n as ie,H as K,r as Rt,i as bt,C as wt,Q as se}from"./rasterProjectionHelper-DaGB8Ymv.js";import{r as ae,p as St}from"./clipUtils-oY08WdMl.js";import{T as vt}from"./rasterFunctionHelper-BFv537F1.js";const xe=8,_t=256;let Tt=0,v=class extends Fe{constructor(){super(...arguments),this._tileFetchQueue=new lt({concurrency:32,process:(t,i)=>this.fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Y.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=Q(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var i,r;this._set("rasterJobHandler",t),N(this)&&((r=(i=this.primaryRasters)==null?void 0:i.rasters)==null||r.forEach(s=>s.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+Tt++}set url(t){this._set("url",Re(t,ne.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=re().then(()=>this._open(t))),this._openPromise}async fetchTile(t,i,r,s={}){const e=s.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(t,i,r,e);if(!n)throw new $("imagery-tile:out-of-bounds","Level for fetch tile out of range");return s={noClip:!0,...s},this.fetchPixels(n,e.size[0],e.size[1],s)}async identify(t,i={}){var H;t=X(P,t).clone().normalize();const{multidimensionalDefinition:r,timeExtent:s}=i,{rasterInfo:e}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:a}=e;let{transposedVariableName:o}=i;const l=a!=null&&n&&(s!=null||Se(r));l&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:a.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=e,{datumTransformation:d}=i;let h=pe(t,c,d);if(!u.intersects(h))return{location:h,value:null};if(e.transform!=null){const J=e.transform.inverseTransform(h);if(!e.nativeExtent.intersects(J))return{location:J,value:null};h=J}let p=0;const y=o!=null&&a!=null&&e.hasMultidimensionalTranspose;if(N(this)){const J=this.primaryRasters.rasters[0];if(y)return J.identify(h,i);const{pixelSize:M}=e,_=3,E=M.x*_/2,W=M.y*_/2,L=new V({xmin:h.x-E,xmax:h.x+E,ymin:h.y-W,ymax:h.y+W,spatialReference:c}),B={interpolation:"nearest",multidimensionalDefinition:r,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:T}=await J.fetchPixels(L,_,_,B),{pixelBlock:k}=await this.fetchPixels(L,_,_,B);if(T==null)return{location:h,value:null};const D=Math.floor(_*_*.5),q=!T.mask||T.mask[D]?T.pixels.map(C=>C[D]):null;let z;return k!=null&&(z=!k.mask||k.mask[D]?k.pixels.map(C=>C[D]):void 0),{location:h,value:q,processedValue:z,pyramidLevel:0}}if(!y){if(i.srcResolution)p=ye(i.srcResolution,e,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(t,i),p==null)return{location:h,value:null}}const g=this.identifyPixelLocation(h,p,null,y);if(g===null)return{location:h,value:null};const{row:f,col:m,rowOffset:x,colOffset:R,blockWidth:S}=g,w=await this._fetchRawTile(p,f,m,i);if(!((H=w==null?void 0:w.pixels)!=null&&H.length))return{location:h,value:null};const F=x*S+R;return this._processIdentifyResult(w,{srcLocation:h,position:F,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,r,s={}){t=It(t),s=this._getRequestOptionsWithSliceId(s);const{_hasNoneOrGCSShiftTransform:e}=this;if(s.requestRawData&&e)return this._fetchPixels(t,i,r,s);const n=Q(t.spatialReference),a=ie(t);if(n==null||a===0||a===1&&this._isGlobalWrappableSource&&e)return this._fetchPixels(t,i,r,s);if(a>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,u=Math.round(n/(c-l)*i),d=u-Math.round((n/2-l)/(c-l)*i);let h=0;const p=[];for(let m=0;m<=a;m++){const x=new V({xmin:m===0?l:-n/2,xmax:m===a?c-n*m:n/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),R=m===0?u-d:m===a?i-h:u;h+=R,p.push(R);const S=s.disableWrapAround&&m>0?null:this._fetchPixels(x,R,r,s);o.push(S)}const y=(await Promise.all(o)).map(m=>m==null?void 0:m.pixelBlock);let g=null;const f={width:i,height:r};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:f,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},s)).pixelBlock:g=te(y,f,{blockWidths:p}),{extent:t,srcExtent:K(t,this.rasterInfo.spatialReference,s.datumTransformation),pixelBlock:g}}async fetchRawPixels(t,i,r,s={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const e=await this._fetchRawTiles(t,i,r,s),{nativeExtent:n,nativePixelSize:a,storageInfo:o}=this.rasterInfo,l=2**t,c=a.x*l,u=a.y*l,d=new V({xmin:n.xmin+c*i.x,xmax:n.xmin+c*(i.x+r.width-1),ymin:n.ymax-u*(i.y+r.height-1),ymax:n.ymax-u*i.y,spatialReference:n.spatialReference});if(!e)return{extent:d,srcExtent:d,pixelBlock:null};const{pixelBlocks:h,mosaicSize:p}=e;if(h.length===1&&h[0]!=null&&h[0].width===r.width&&h[0].height===r.height)return{extent:d,srcExtent:d,pixelBlock:e.pixelBlocks[0]};const y=t>0?o.pyramidBlockWidth:o.blockWidth,g=t>0?o.pyramidBlockHeight:o.blockHeight,f={x:i.x%y,y:i.y%g};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:r,clipOffset:f,clipSize:r,coefs:null,sampleSpacing:null,interpolation:s.interpolation,alignmentInfo:null,blockWidths:null},s)).pixelBlock:m=te(h,p,{clipOffset:f,clipSize:r}),{extent:d,srcExtent:d,pixelBlock:m}}fetchRawTile(t,i,r,s){throw new $("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return K(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?nt(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,r=0){const{customFetchParameters:s}=this.ioConfig,{range:e,query:n,headers:a}=i;r=r??i.retryCount??this.ioConfig.retryCount;const o=e?{Range:`bytes=${e.from}-${e.to}`}:null;try{return await be(t,{...i,query:{...n,...s},headers:{...a,...o}})}catch(l){if(r>0)return r--,this.request(t,i,r);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Oe(t,i)}getTileExtentFromTileInfo(t,i,r,s){const e=s.lodAt(t);return e?this.getTileExtent({x:e.resolution,y:e.resolution},i,r,s.origin,s.spatialReference,s.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:r,pixelSize:s}=this.rasterInfo,{pyramidResolutions:e}=t;if(!t.tileInfo){const n=[],a=t.maximumPyramidLevel||0;let o=(s.x+s.y)/2,l=1/.0254*96*o;for(let u=0;u<=a&&(n.unshift(new Be({level:a-u,resolution:o,scale:l})),u!==a);u++)if(e){const d=(e[u].x+e[u].y)/2;l*=d/o,o=d}else o*=2,l*=2;const c=new P({x:r.xmin,y:r.ymax,spatialReference:i});t.tileInfo=new Y({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:n}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,r=512,s){const{width:e,height:n,nativeExtent:a,pixelSize:o,spatialReference:l}=t,c=new P({x:a.xmin,y:a.ymax,spatialReference:l});s==null&&(s=Math.max(0,Math.round(Math.log(Math.max(e,n))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],s);t.storageInfo=new rt({blockWidth:i,blockHeight:r,pyramidBlockWidth:i,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:s,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,r,s,e,n=0,a=2){if(e.length===1&&n>0){e=[...e];let{x:u,y:d}=e[0];for(let h=0;h<n;h++)u*=a,d*=a,e.push({x:u,y:d})}const o=[],{x:l,y:c}=s;for(let u=0;u<e.length;u++){const{x:d,y:h}=e[u];o.push({minCol:Math.floor((t.xmin-l+.1*d)/i/d),maxCol:Math.floor((t.xmax-l-.1*d)/i/d),minRow:Math.floor((c-t.ymax+.1*h)/r/h),maxRow:Math.floor((c-t.ymin-.1*h)/r/h)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:s}=this.rasterInfo.storageInfo;if(t===0)return i;if(r!=null&&r.length)return r[t-1];const e=s**t;return{x:i.x*e,y:i.y*e}}identifyPixelLocation(t,i,r,s){const{spatialReference:e,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=a,u=s&&c!=null?c.tileSize[0]:a.blockWidth,d=s&&c!=null?c.tileSize[1]:a.blockHeight,h=pe(t,e,r);if(!n.intersects(h)||i<0||i>o)return null;const p=this.getPyramidPixelSize(i),{x:y,y:g}=p,f=(l.y-h.y)/g/d,m=(h.x-l.x)/y/u,x=Math.min(d-1,Math.floor((f-Math.floor(f))*d)),R=Math.min(u-1,Math.floor((m-Math.floor(m))*u));return{pyramidLevel:i,row:Math.floor(f),col:Math.floor(m),rowOffset:x,colOffset:R,blockWidth:u,srcLocation:h}}getTileExtent(t,i,r,s,e,n){const[a,o]=n,l=s.x+r*a*t.x,c=l+a*t.x,u=s.y-i*o*t.y,d=u-o*t.y;return new V({xmin:l,xmax:c,ymin:d,ymax:u,spatialReference:e})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,r){const s=this.rasterInfo.storageInfo.blockBoundary[t];return!s||s.maxRow<i||s.maxCol<r||s.minRow>i||s.minCol>r}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:r,height:s}=t,e=we.WebMercator;t.spatialReference=e,t.extent=t.nativeExtent=new V({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-s,spatialReference:e}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new P({x:1,y:1,spatialReference:e});const{extent:n,storageInfo:a}=t;if(a){a.origin=new P({x:n.xmin,y:n.ymax,spatialReference:e});const{pyramidResolutions:o,tileInfo:l}=a;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=a.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,d)=>{u.resolution=c*2**d,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,r,s={}){let e=ie(t);if(e>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,i,r,s),{pyramidLevel:a,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:d}=n;if(c===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:h}=this,p=h.transform,y=(p==null?void 0:p.type)==="gcs-shift",g=Q(t.spatialReference)!=null;!y&&g||(e=ie(n.srcExtent,y));const f=await this._fetchRawTiles(a,d,{width:c,height:u,wrapCount:e},s);if(!f)return{extent:t,srcExtent:l,pixelBlock:null};const m=h.storageInfo,x=a>0?m.pyramidBlockWidth:m.blockWidth,R=a>0?m.pyramidBlockHeight:m.blockHeight;let{x:S,y:w}=h.pixelSize;if(a>0){const{pyramidResolutions:O,pyramidScalingFactor:Pe}=m;if(O!=null&&O[a-1])({x:S,y:w}=O[a-1]);else{const le=Pe**a;S*=le,w*=le}}const F=h.spatialReference,H=new P({x:S,y:w,spatialReference:F}),J=x===c&&R===u&&d.x%x===0&&d.y%R===0,M=new P({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),_=!t.spatialReference.equals(F),E=F.isGeographic?1e-9:1e-4,{datumTransformation:W}=s;if(!_&&J&&f.pixelBlocks.length===1&&x===i&&R===r&&kt(o,M,E))return{extent:t,srcExtent:l,srcTilePixelSize:H,pixelBlock:f.pixelBlocks[0]};const L=g&&Q(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,B=s.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");B&&!this.rasterJobHandler&&await re();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:M.toJSON(),datumTransformation:W,rasterTransform:p,hasWrapAround:e>0||L,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:B},s):Rt({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:M,datumTransformation:W,rasterTransform:p,hasWrapAround:e>0||L,isAdaptive:!1,includeGCSGrid:B});let k;const D=!s.requestRawData,q={rows:T.spacing[0],cols:T.spacing[1]},z=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,f.extent.xmin):void 0,{pixelBlocks:C,mosaicSize:A,isPartiallyFilled:U}=f;let G=null;if(this.rasterJobHandler)({pixelBlock:k,localNorthDirections:G}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:A,destDimension:D?{width:i,height:r}:null,coefs:D?T.coefficients:null,sampleSpacing:D?q:null,projectDirections:B,gcsGrid:B?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:s.interpolation,alignmentInfo:z,blockWidths:null},s));else{const O=te(C,A,{alignmentInfo:z});k=D?_e(O,{width:i,height:r},T.coefficients,q,s.interpolation):O,B&&T.gcsGrid&&(G=pt({width:i,height:r},T.gcsGrid),k=yt(k,this.rasterInfo.dataType,G))}return s.requestRawData||B?{extent:t,srcExtent:l,srcTilePixelSize:H,pixelBlock:k,transformGrid:T,localNorthDirections:G,isPartiallyFilled:U}:{extent:t,srcExtent:l,srcTilePixelSize:H,pixelBlock:k}}async _fetchRawTiles(t,i,r,s){const{origin:e,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:u,height:d,wrapCount:h}=r;const p=this._getRasterTileAlignmentInfo(t,0);s.buffer&&(l-=s.buffer.cols,c-=s.buffer.rows,u+=2*s.buffer.cols,d+=2*s.buffer.rows);let y=0,g=0,f=0;h&&p!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:f,rightPadding:y}=p,g*p.blockWidth-y>=l+u&&(y=0));const m=Math.floor(l/a),x=Math.floor(c/o),R=Math.floor((l+u+y-1)/a),S=Math.floor((c+d+y-1)/o),w=n[t];if(!w)return null;const{minRow:F,minCol:H,maxCol:J,maxRow:M}=w;if(h===0&&(S<F||R<H||x>M||m>J))return null;const _=new Array;let E=!1;const W=this.ioConfig.allowPartialFill==null?s.allowPartialFill:this.ioConfig.allowPartialFill;for(let z=x;z<=S;z++)for(let C=m;C<=R;C++){let A=C;if(!s.disableWrapAround&&h&&p!=null&&g<=C&&(A=C-g-f),z>=F&&A>=H&&M>=z&&J>=A){const U=this._fetchRawTile(t,z,A,s);W?_.push(new Promise(G=>{U.then(O=>G(O)).catch(()=>{E=!0,G(null)})})):_.push(U)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const L=await Promise.all(_),B={height:(S-x+1)*o,width:(R-m+1)*a},{spatialReference:T}=this.rasterInfo,k=this.getPyramidPixelSize(t),{x:D,y:q}=k;return{extent:new V({xmin:e.x+m*a*D,xmax:e.x+(R+1)*a*D,ymin:e.y-(S+1)*o*q,ymax:e.y-x*o*q,spatialReference:T}),pixelBlocks:L,mosaicSize:B,isPartiallyFilled:E}}_fetchRawTile(t,i,r,s){var d;const{storageInfo:e}=this.rasterInfo,n=e.transposeInfo!=null&&!!s.transposedVariableName;if(!n){const h=e.blockBoundary[t];if(!h)return Promise.resolve(null);const{minRow:p,minCol:y,maxCol:g,maxRow:f}=h;if(i<p||r<y||i>f||r>g)return Promise.resolve(null)}const a=n?s.transposeVariableName:s.sliceId,o=e.isBsqTile?s.bandIds:null,l=ct(this.rasterId,a,o),c=`${t}/${i}/${r}`;let u=ut(l,s.registryId,c);if(u==null){const h=new AbortController,p=(d=s.bandIds)==null?void 0:d.slice();if(p!=null&&p.length&&e.isBsqTile){const y=new Set(p),g=[],f=Array.from(y);for(const m of f)g.push(this._tileFetchQueue.push({pyramidLevel:t,row:i,col:r,options:{...s,bandIds:[m]}},{signal:h.signal}));u=Promise.all(g).then(m=>{if(m.some(x=>x==null))return null;if(f.length!==p.length){const x=[];for(const R of p){let S=m[f.indexOf(R)];x.includes(S)&&(S=S.clone()),x.push(S)}m=x}return this.rasterJobHandler?this.rasterJobHandler.compositeBands({pixelBlocks:m},{signal:h.signal,transferPixelsToWorker:!0}):xt(m)})}else u=this._tileFetchQueue.push({pyramidLevel:t,row:i,col:r,options:s},{signal:h.signal});ht(l,s.registryId,c,u,h),u.catch(()=>mt(l,s.registryId,c))}return s.signal&&De(s,()=>{dt(l,s.registryId,c)}),u}_computeMagDirValues(t){var l;const{bandCount:i,dataType:r}=this.rasterInfo;if(!(i===2&&r==="vector-magdir"||r==="vector-uv")||(t==null?void 0:t.length)!==2||!((l=t[0])!=null&&l.length))return null;const s=t[0].length;if(r==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[e,n]=t,a=[],o=[];for(let c=0;c<s;c++){const[u,d]=gt([e[c],n[c]]);a.push(u),o.push(d)}return[a,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=bt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,r,s={}){const e={datumTransformation:s.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};s.srcResolution&&(e.srcResolution=s.srcResolution,this._updateSourceDataInfo(t,e));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:l}=e,c=a/i,u=o/r,d=l<n&&c*u>=16,h=l===n&&this._requireTooManySrcTiles(a,o,i,r);if(d||h||a===0||o===0){const p=new P({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference});let y=wt(p,this.rasterInfo.spatialReference,t,e.datumTransformation);const g=!y||s.srcResolution&&y.x+y.y<s.srcResolution.x+s.srcResolution.y;if(d&&s.srcResolution&&g){const f=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-l+3>=f){const m=2**f;y={x:s.srcResolution.x*m,y:s.srcResolution.y*m}}}y&&(e.srcResolution=y,this._updateSourceDataInfo(t,e))}return this._requireTooManySrcTiles(e.srcWidth,e.srcHeight,i,r)&&(e.srcWidth=0,e.srcHeight=0),e}_requireTooManySrcTiles(t,i,r,s){const{tileInfo:e}=this.rasterInfo.storageInfo,n=Math.ceil(t/e.size[0])*Math.ceil(i/e.size[1]),a=t/r,o=i/s,l=Math.max(1,(r+s)/1024);return n>=_t*l||a>xe||o>xe}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:r}=this,s=r.spatialReference,{srcResolution:e,datumTransformation:n}=i,{pyramidLevel:a,pyramidResolution:o,excessiveReading:l}=ye(e,r,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||K(t,s,n);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:d}=r.storageInfo,{width:h,height:p,ul:y}=We(c,d,o,a);i.pyramidLevel=a,i.pyramidResolution=o,i.srcWidth=h,i.srcHeight=p,i.ul=y}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:r,position:s,pyramidLevel:e,useTransposedTile:n}=i,a=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[s]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!n){const f=t.pixels.map(R=>R[s]),m={location:r,value:f,pyramidLevel:e},x=this._computeMagDirValues(f.map(R=>[R]));return x!=null&&x.length&&(m.magdirValue=x.map(R=>R[0])),m}let l=t.pixels.map(f=>f.slice(s*a,s*a+a)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:d}=i;let h=Ne(o,d.transposedVariableName);if(u){const f=Ee(h,d.multidimensionalDefinition,d.timeExtent);l=l.map(m=>f.map(x=>m[x])),c=c==null?void 0:c.map(m=>f.map(x=>m[x])),h=f.map(m=>h[m])}const p=t.noDataValues||this.rasterInfo.noDataValue,y={pixels:l,pixelType:t.pixelType};let g;return p!=null&&(ft(y,p),g=y.mask),{location:r,value:null,dataSeries:h.map((f,m)=>{const x={value:(g==null?void 0:g[m])===0?null:l.map(R=>R[m]),multidimensionalDefinition:f.multidimensionalDefinition.map(R=>new ve({...R,isSlice:!0}))};return c!=null&&c.length&&(x.magdirValue=[c[0][m],c[1][m]]),x}),pyramidLevel:e}}};function kt(t,i,r){return Math.abs(t.x-i.x)<r&&Math.abs(t.y-i.y)<r}I([b()],v.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],v.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],v.prototype,"_openPromise",void 0),I([b()],v.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],v.prototype,"rasterId",null),I([b(Ie)],v.prototype,"url",null),I([b({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),I([b()],v.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],v.prototype,"rasterInfo",void 0),I([b()],v.prototype,"ioConfig",void 0),I([b()],v.prototype,"sourceJSON",void 0),v=I([oe("esri.layers.support.rasterDatasets.BaseRaster")],v);const Pt=40;let j=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,r,s={}){var R,S;const{rasters:e,rasterIds:n}=this.primaryRasters;let a=!1;const{interpolation:o}=s,l=(R=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:R.hasFocalFunction;!s.requestRawData&&l&&(a=e.length===1&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:a}),s.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,s={...s,requestRawData:!1});const c=e.map(w=>w.fetchPixels(t,i,r,s)),u=await Promise.all(c),d=u.map(w=>w.pixelBlock),h=a||s.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(s.skipRasterFunction||d.every(w=>w==null))return u[0];const p=((S=u.find(w=>w.pixelBlock!=null))==null?void 0:S.extent)??t;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:h,primaryRasterIds:n}):this.rasterFunction.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:h,primaryRasterIds:n});const{transformGrid:g}=u[0];if(!a||y==null||g==null){const w=s.noClip?null:this.getClippingGeometry(p.spatialReference);return!s.noClip&&y!=null&&w&&(y=await ae(y,p,w)),{...u[0],pixelBlock:y}}const f={rows:g.spacing[0],cols:g.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:i,height:r},coefs:g.coefficients,sampleSpacing:f,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:m=_e(y,{width:i,height:r},g.coefficients,f,o);const x=s.noClip?null:this.getClippingGeometry(t.spatialReference);return s.noClip||m==null||x==null||(m=await ae(m,t,x)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:m}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const r=Bt(t);let s=this._clippingGeometry.get(r);return s!=null||(s=t.equals(i.spatialReference)?i:se(i,t),this._clippingGeometry.set(r,s)),s}async _open(t){var c,u,d,h;const{rasterFunction:i}=this;i.isRoot=!0,(u=(c=this.primaryRasters)==null?void 0:c.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((d=this.primaryRasters.rasters)==null||d.forEach(p=>p.rasterJobHandler=this.rasterJobHandler)));const{rasters:r,rasterIds:s}=this.primaryRasters,e=r.map(p=>p.rasterInfo?void 0:p.open(t));await Promise.all(e);const n=r.map(({rasterInfo:p})=>p),a=i.bind({rasterInfos:n,rasterIds:s});if(i.rawSourceRasterInfos=n,!a.success||n.length===0)throw new $("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=i.functionName==="Table"?i:(h=i.functionArguments)==null?void 0:h.raster;(o==null?void 0:o.functionName)==="Table"&&(i.rasterInfo.attributeTable=Ce.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=n[0];this.hasUniqueSourceStorageInfo=n.length===1||n.slice(1).every(p=>Ft(p,l)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var t;return(t=this.rasterJobHandler)==null?void 0:t.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t==null?void 0:t.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:r}=this.rasterInfo,s=await Z(()=>import("./densifyOperator-BpEieVOf.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url),e=await Z(()=>import("./differenceOperator-D7538bjp.js").then(a=>a.d),__vite__mapDeps([11,3,4,5,6,7,1,2,8,9,10]),import.meta.url);let n=s.execute(He.fromExtent(r),2*(r.width+r.height)/Pt);n=se(n,i.spatialReference),i=e.execute(n,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function Ft(t,i){const{storageInfo:r,pixelSize:s,spatialReference:e,extent:n}=t,{storageInfo:a,pixelSize:o,spatialReference:l,extent:c}=i;return s.x===o.x&&s.y===o.y&&e.equals(l)&&n.equals(c)&&r.blockHeight===a.blockHeight&&r.blockWidth===a.blockWidth&&r.maximumPyramidLevel===a.maximumPyramidLevel&&r.firstPyramidLevel===a.firstPyramidLevel&&r.pyramidBlockWidth===a.pyramidBlockWidth&&r.pyramidBlockHeight===a.pyramidBlockHeight&&r.pyramidScalingFactor===a.pyramidScalingFactor}function Bt(t){return String(t.wkid??t.wkt??t.wkt2)}I([b({type:String,json:{write:!0}})],j.prototype,"datasetFormat",void 0),I([b()],j.prototype,"tileType",void 0),I([b()],j.prototype,"rasterFunction",void 0),I([b()],j.prototype,"primaryRasters",void 0),j=I([oe("esri.layers.support.rasterDatasets.FunctionRaster")],j);const ge=1e3,qt=t=>{const i=t;let r=class extends i{constructor(...e){var n;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=N((n=e[0])==null?void 0:n.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Re(e,ne.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;if(e){const a=n==null?void 0:n.find(({name:o})=>o===e);return a==null?void 0:a.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){var l,c;const o=(c=(l=n==null?void 0:n.layerDefinition)==null?void 0:l.drawingInfo)==null?void 0:c.renderer;return Ue(o,a)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=X(Qe,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:o}=e;if(o==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=o;const{spatialReference:c}=a;if(!o.spatialReference.equals(c)){await re();const m=o.type==="extent"?K(o,c):se(o,c);if(m==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=m}const u=e.pixelSize??new P({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:c}),{extent:d,width:h,height:p}=St(a,l,u),y=await this.fetchPixels(d,h,p,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ae(y.pixelBlock,d,l),f=this._rasterJobHandler;return f?f.computeStatisticsHistograms({pixelBlock:g},n):at(g)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=Le({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:a}=this;if(!e||!n||!a)return;const{rasterInfo:o}=this.raster,l=ce(o,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),c=l==null?void 0:l.name,u=me(o,c);return this._updateSymbolizer(n,a,c,u)}async applyRenderer(e,n,a){const o=e==null?void 0:e.pixelBlock;if(!(o!=null&&o.pixels&&o.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:c}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:l,symbolizer:this.symbolizer},a);return c}getRawDisplayBandIds(){let{bandIds:e,raster:n}=this;if(this.rasterFunction&&N(n)){const a=n.rasterFunction.rawInputBandIds;e=e!=null&&e.length&&(a!=null&&a.length)&&n.rasterInfo.bandCount!==1?e.map(o=>a[Math.min(o,a.length-1)]):a}return e&&e.length>3&&e.every((a,o)=>a===o)?null:e}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const o=Me(e);return Y.create({size:256,spatialReference:e,origin:o?{x:o.origin[0],y:o.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,o={}){var c;if(s(this),o.requestAsImageElement){const u=this.getTileUrl(e,n,a);return be(u,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then(d=>d.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null){const u=o.tileInfo||l.storageInfo.tileInfo,d=this.raster.getTileExtentFromTileInfo(e,n,a,u);if(d)return{extent:d,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((c=this.renderer)==null?void 0:c.type)==="raster-shaded-relief"&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,o)}async fetchPixels(e,n,a,o={}){var c,u;if(this.serviceRasterInfo.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a);const l=await this.raster.fetchPixels(e,n,a,o);return(c=o.bandIds)!=null&&c.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=(u=l.pixelBlock)==null?void 0:u.extractBands(o.bandIds)),l}async getSamples(e,n){var u;if(await this.load(),(e=X(Xe,e).clone()).interpolation&&e.interpolation!=="nearest")throw new $("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=(u=e.mosaicRule)==null?void 0:u.multidimensionalDefinition,o={...n,multidimensionalDefinition:a},l=(await this._getSampleLocations(e)).map(d=>this.identify(d,o).then(h=>(h.location=d,h))),c=(await Promise.all(l)).flatMap((d,h)=>this._convertRasterIdentifyResultToSample(d,h));return new Ke({samples:c})}async identify(e,n={}){var u,d;await this.load(),e=X(P,e).clone().normalize();const{raster:a,serviceRasterInfo:o}=this;if((o==null?void 0:o.multidimensionalInfo)!=null&&!(o.hasMultidimensionalTranspose&&!(!Se(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const l=(u=this.multidimensionalSubset)==null?void 0:u.areaOfInterest;if(l&&!l.contains(e))throw new $("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let c;if((d=this.serviceRasterInfo)!=null&&d.storageInfo.isBsqTile){const h=N(a)?this.getRawDisplayBandIds():this.bandIds;c=h!=null&&h.length?h:void 0}return a.identify(e,{...n,bandIds:c})}hasStandardTime(){var o,l,c;const e=(o=this.serviceRasterInfo)==null?void 0:o.multidimensionalInfo;if(e==null||((l=this.serviceRasterInfo)==null?void 0:l.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=(c=n==null?void 0:n[0])==null?void 0:c.variableName;return e.variables.some(u=>u.name===a&&(!(n!=null&&n[0].dimensionName)||u.dimensions.some(d=>d.name==="StdTime")))}getStandardTimeValue(e){return new Date(qe(e)).toISOString()}getMultidimensionalSubsetVariables(e){var a;const n=e??((a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo);return Ae(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ge(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&N(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;s(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,N(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:a,type:o}=n;if(o==="multipoint")return n.points.map(m=>new P({x:m[0],y:m[1],spatialReference:a}));if(o==="polyline"){let m=n;if(e.sampleCount||e.sampleDistance){const x=await Z(()=>import("./densifyOperator-BpEieVOf.js").then(F=>F.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url),R=(await Z(async()=>{const{execute:F}=await import("./lengthOperator-J6a_F19i.js").then(H=>H.l);return{execute:F}},__vite__mapDeps([12,1,2,3,5,4,6,7,8,9,10]),import.meta.url)).execute(n,{unit:"meters"}),S=Math.min(e.sampleCount||100,ge);let w=e.sampleDistance;w||(w=R/(S+(m.paths[0].length===2?1:0))),m=x.execute(n,w,{unit:"meters"})}return m.paths.flatMap(x=>x.map(R=>new P({x:R[0],y:R[1],spatialReference:a})))}const l=Math.min(e.sampleCount||100,ge),c=n.type==="extent",u=c?n:n.extent,d=Math.sqrt(u.width*u.height/l),h=u.height/d,p=u.width/d,{xmin:y,ymax:g}=u,f=[];for(let m=0;m<h;m++)for(let x=0;x<p;x++){const R=new P({x:y+(x+.5)*d,y:g-(m+.5)*d,spatialReference:a});(c||n.contains(R))&&f.push(R)}return f}_configDefaultInterpolation(){var e;if(this.interpolation==null){s(this);const{raster:n}=this,a=Ye(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(e="no"){var h,p,y;s(this);const{rasterInfo:n}=this.raster,a=ce(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=a==null?void 0:a.name,l=Ze({variableName:o,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(l==null?void 0:l.bandIds)??et(n)),!this.renderer||e==="override"){const g=tt(this.raster),f=(l==null?void 0:l.renderer)??de(n,{bandIds:this.bandIds,variableName:o,rasterFunctionColorRamp:g}),m=n.statistics,x=m&&m.length>0?m[0]:null,R=(x==null?void 0:x.max)??0,S=(x==null?void 0:x.min)??0;this.raster.datasetFormat==="WCSServer"&&f.type==="raster-stretch"&&(R>1e24||S<-1e24)&&(f.dynamicRangeAdjustment=!0,f.customStatistics=null,f.stretchType==="none"&&(f.stretchType="min-max")),this.renderer=f}const c=it({...this.renderer.toJSON(),variableName:o}),u=me(n,o);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=u):this.symbolizer=new ot({rendererJSON:c,rasterInfo:u});const d=this.symbolizer.bind();if(d.success){if(e==="auto"){const{colormap:g}=this.raster.rasterInfo,f=this.renderer;if(g!=null&&f.type==="raster-colormap"){const m=de(this.raster.rasterInfo);JSON.stringify(m)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if(f.type==="raster-stretch"){const m=(p=this.bandIds)==null?void 0:p.length,x=(y=f.customStatistics)==null?void 0:y.length;!f.dynamicRangeAdjustment&&x&&m&&x!==m&&this._configDefaultRenderer("override")}}}else ne.getLogger(this).warn("imagery-tile-mixin",d.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var d;if(this._isConstructedFromFunctionRaster&&N(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ue.fromJSON(h)))}let e,n=this.raster,a=!1;N(n)?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:o}=this;if(o){const h={raster:n};e.length>1&&e.forEach(g=>h[g.url]=g);const p=vt(((d=o.functionDefinition)==null?void 0:d.toJSON())??o.toJSON(),h),y=new j({rasterFunction:p});y.rasterJobHandler=this._rasterJobHandler,await y.open(),this.raster=y}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!a&&!o)return;const{bandIds:l}=this,{bandCount:c}=this.raster.rasterInfo,u=l!=null&&l.length?l.some(h=>h>=c):c>=3;l&&(u||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){var u;const{rasterInfo:a}=this.raster,o=a.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),l=(a.pixelSize.x+a.pixelSize.y)/2*o;if(!((u=e.dataSeries)!=null&&u.length))return[new fe({location:e.location,pixelValue:e.value,locationId:n,resolution:l})];const c=[];return e.dataSeries.forEach(({value:d,multidimensionalDefinition:h},p)=>{const y={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:f})=>f).join(",")};for(const{dimensionName:f,values:m}of h){y[f]=Array.isArray(m[0])?m[0][0]:m[0];const x=m[m.length-1];y[`${f}_Max`]=Array.isArray(x)?x[x.length-1]:x}const g=new fe({location:e.location,pixelValue:d,rasterId:p,locationId:n,resolution:l,attributes:y});c.push(g)}),c}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new $("imagery-tile","no raster")}return I([b({clonable:!1})],r.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],r.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],r.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],r.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[Je],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],r.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],r.prototype,"copyright",void 0),I([b({json:{read:!1}})],r.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),ze(st)],r.prototype,"interpolation",void 0),I([b()],r.prototype,"ioConfig",void 0),I([b({type:[ve],json:{write:!0}})],r.prototype,"multidimensionalDefinition",null),I([b({type:je,json:{write:!0}})],r.prototype,"multidimensionalSubset",void 0),I([b()],r.prototype,"raster",void 0),I([b({type:ue})],r.prototype,"rasterFunction",null),I([b()],r.prototype,"serviceRasterInfo",void 0),I([b()],r.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:we,json:{read:!1}})],r.prototype,"spatialReference",void 0),I([b({type:Y})],r.prototype,"tileInfo",void 0),I([b(Ie)],r.prototype,"url",null),I([b({types:he})],r.prototype,"renderer",null),I([b({types:he,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ve,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],r.prototype,"internalRenderer",null),I([$e("internalRenderer")],r.prototype,"readRenderer",null),I([b({clonable:!1})],r.prototype,"symbolizer",void 0),r=I([oe("esri.layers.mixins.ImageryTileMixin")],r),r};function ee(t,i){if(!t||!i)return[];let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const s=[];if(i){const n=ee(t,r);for(let a=0;a<n.length;a++)ee(n[a],i).forEach(o=>s.push(o));return s}const e=t.getElementsByTagNameNS("*",r);if(!e||e.length===0)return[];for(let n=0;n<e.length;n++)s.push(e[n]||e.item(n));return s}function Te(t,i){if(!t||!i)return null;let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const s=ee(t,r);return s.length>0?i?Te(s[0],i):s[0]:null}function ke(t,i=null){const r=i?Te(t,i):t;let s;return r?(s=r.textContent||r.nodeValue,s?s.trim():null):null}function Dt(t,i){const r=ee(t,i),s=[];let e;for(let n=0;n<r.length;n++)e=r[n].textContent||r[n].nodeValue,e&&(e=e.trim(),e!==""&&s.push(e));return s}function At(t,i=null){const r=ke(t,i);return(r==null?void 0:r.split(" ").map(s=>Number(s)))??[]}function Gt(t,i){return Dt(t,i).map(r=>Number(r))}function jt(t,i){const r=ke(t,i);return Number(r)}function Vt(t,i){var e;const r=(e=t==null?void 0:t.nodeName)==null?void 0:e.toLowerCase(),s=i.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===s}function Ut(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{v as K,qt as X,Ut as c,Te as e,Vt as i,Dt as l,j as m,ee as n,jt as o,At as r,ke as t,Gt as u};

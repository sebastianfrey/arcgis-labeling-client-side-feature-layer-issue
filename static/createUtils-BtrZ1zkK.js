import{aJ as v,aK as S,aM as x,aL as J,dl as C,df as K,kr as X,iX as D,ac as V,hS as Y,iW as ee,kM as te,kN as se,c3 as ae,ae as re,kO as H,kP as ne,kQ as ie,b3 as d,gn as oe,bB as le,fN as ce,bE as he,bC as ue,jt as N,N as I,fM as pe,dk as fe,kR as A,a$ as de,h as me,jM as ye,gI as B,gN as xe,kS as ge,f9 as Re}from"./index-C_bK48d2.js";import{j as Me}from"./geodesicUtils-CTZo9mb6.js";import{c as we}from"./distanceOperator-Dulc5dHh.js";import{c as Te,u as be}from"./simplifyOperator-DCwRzIwh.js";import{R as ve,L as We}from"./quat-BPAPKRxq.js";import{e as O}from"./quatf64-aQ5IuZRd.js";var z;let M=z=class extends C{constructor(t){super(t),this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const t=this.center,e=this.numberOfPoints;if(this.hasZ=(t==null?void 0:t.hasZ)??!1,this.rings.length!==0||!t)return;const s=K(this.radius,this.radiusUnit,"meters"),r=t.spatialReference;let i,a="geographic";if(r.isWebMercator?a="webMercator":((r.wkid&&X[r.wkid])!=null||(r.wkt2||r.wkt)&&D(r.wkt2||r.wkt))&&(a="projected"),this.geodesic){let n;switch(a){case"webMercator":n=V(t);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=t}i=this._createGeodesicCircle(n,s,e),a==="webMercator"&&(i=Y(i))}else{let n;a==="webMercator"||a==="projected"?n=s/ee(t.spatialReference):a==="geographic"&&(n=te(s,"meters",se(t.spatialReference).radius)),i=this._createPlanarCircle(t,n,e)}this.spatialReference=i.spatialReference,this.addRing(i.rings[0])}get center(){return this._get("center")}set center(t){this._set("center",ae(x,t))}clone(){const{center:t,numberOfPoints:e,radius:s,radiusUnit:r,geodesic:i}=this;return new z({center:t==null?void 0:t.clone(),numberOfPoints:e,radius:s,radiusUnit:r,geodesic:i})}_createGeodesicCircle(t,e,s){const r=[],i=[t.x,t.y];for(let a=0;a<360;a+=360/s){const n=this.hasZ?[0,0,t.z??0]:[0,0];Me(n,i,a,e,re.WGS84),r.push(n)}return r.push(r[0]),new C({rings:[r]})}_createPlanarCircle(t,e,s){const r=[],i=2*Math.PI/s;for(let a=0;a<s;++a){const n=i*a,c=[t.x+Math.cos(-n)*e,t.y+Math.sin(-n)*e];this.hasZ&&c.push(t.z??0),r.push(c)}return r.push(r[0]),new C({spatialReference:t.spatialReference,rings:[r]})}};v([S({type:x,useTypeForAutocast:!1,value:null})],M.prototype,"center",null),v([S()],M.prototype,"geodesic",void 0),v([S()],M.prototype,"numberOfPoints",void 0),v([S()],M.prototype,"radius",void 0),v([S()],M.prototype,"radiusUnit",void 0),M=z=v([J("esri.geometry.Circle")],M);const $e=M;function U(t,e,s=null){return s!=null?[t,e,s]:[t,e]}function o(t,e,s=null){return s!=null?{x:t,y:e,z:s}:{x:t,y:e}}class E{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(s=>this.mapToLocal(s)).filter(I)}get doUnnormalization(){return!1}}let Se=class extends E{constructor(e,s,r=null){super(s),this._defaultZ=r,this.transform=H(),this.transformInv=H(),this.transform=ne(e),ie(this.transformInv,this.transform)}makeMapPoint(e,s){return U(e,s,this._defaultZ)}mapToLocal(e){return o(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return U(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}};class Fe extends E{constructor(e,s){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=d(),this.tangentFrameUpWS=d(),this.tangentFrameRightWS=d(),this.tangentFrameForwardWS=d(),this.localFrameRightWS=d(),this.localFrameUpWS=d(),this.worldToLocalTransform=O(),this.localToWorldTransform=O(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=s,this.defaultZ=s.hasZ?s.z:null;const r=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const i=d();oe(i,this.tangentFrameForwardWS,le(r,this.tangentFrameForwardWS)),ce(this.localFrameRightWS,r,i),he(this.localFrameRightWS,this.localFrameRightWS),ue(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),ve(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),We(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,s){return U(e,s,this.defaultZ)}mapToLocal(e){const s=d();this.view.renderCoordsHelper.toRenderCoords(new x({x:e[0],y:e[1],spatialReference:this.spatialReference}),s),N(s,s,this.worldToLocalTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(s,new x({spatialReference:this.view.spatialReference}));return r!=null?o(r.x/this.scale,r.y/this.scale):null}localToMap(e){const s=d();this.view.renderCoordsHelper.toRenderCoords(new x({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),s),N(s,s,this.localToWorldTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(s,new x({spatialReference:this.view.spatialReference}));return r!=null?U(r.x,r.y,this.defaultZ):null}}function _e(t,e){if(t.type==="2d")return new Se(t.state.transform,t.spatialReference,e.length>2?e[2]:null);if(t.type==="3d"){const s=e.length>2?new x({x:e[0],y:e[1],z:e[2],spatialReference:t.spatialReference}):new x({x:e[0],y:e[1],spatialReference:t.spatialReference});return new Fe(t,s)}return null}function w(t,e){const s=new x({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(s.z=t[2]),s}function Ze(t,e){return new pe({points:t,spatialReference:e})}function je(t,e,s){const r=new fe({paths:t,spatialReference:e});return s&&A(r),r}function L(t,e,s,r=!0){const i=de(t);i.forEach(n=>{const c=n[0],l=n[n.length-1];me(c,l)&&n.length!==1||n.push(n[0])});let a=new C({rings:i,spatialReference:e});return a.rings.forEach(n=>{ye(n)||n.reverse()}),s&&A(a),r&&!Te(a)&&B(e)&&(a=be(a)||a),a}function He(t,e,s){const r=e.mapToLocalMultiple(t),i=[],a={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y},c=Math.round(n.x-a.x),l=Math.round(n.y-a.y),p=Math.max(Math.abs(c),Math.abs(l));if(s){const h={x:a.x+p,y:a.y+p},m={x:a.x-p,y:a.y-p};i.push(o(h.x,m.y),o(m.x,m.y),o(m.x,h.y),o(h.x,h.y))}else{const h={x:c>0?a.x+p:a.x-p,y:l>0?a.y+p:a.y-p};i.push(o(a.x,a.y),o(h.x,a.y),o(h.x,h.y),o(a.x,h.y))}return G(L([i.map(h=>e.localToMap(h)).filter(I)],e.spatialReference,e.doUnnormalization,!0),i,e)}function Ne(t,e,s){let r=e.mapToLocalMultiple(t);if(r.length===1){const l=r[0];r=[o(l.x-48,l.y+48),o(l.x+48,l.y-48),o(l.x+48,l.y-48),o(l.x-48,l.y+48)]}const i=[],a={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y};if(s){const c=Math.round(n.x-a.x),l=Math.round(n.y-a.y);i.push(o(a.x-c,a.y-l),o(n.x,a.y-l),o(n.x,n.y),o(a.x-c,n.y))}else i.push(o(a.x,a.y),o(n.x,a.y),o(n.x,n.y),o(a.x,n.y));return G(L([i.map(c=>e.localToMap(c)).filter(I)],e.spatialReference,e.doUnnormalization,!0),i,e)}function G(t,e,s){const r=P(e[3],e[2],s),i=P(e[1],e[2],s),a=P(e[0],e[1],s),n=P(e[0],e[3],s);return{geometry:t,midpoints:r!=null&&i!=null&&a!=null&&n!=null?{top:r,right:i,bottom:a,left:n}:null}}function P(t,e,s){W[0]=t.x,W[1]=t.y,W[2]=0,$[0]=e.x,$[1]=e.y,$[2]=0,xe(W,W,$,.5),k.x=W[0],k.y=$[1],k.z=$[2];const r=s.localToMap(k);return r!=null?w(r,s.spatialReference):null}const k=o(0,0,0),W=d(),$=d();function Oe(t,e,s,r){const i=e.mapToLocalMultiple(t);let a=null,n=null;if(s)a=i[0],n=i[1];else{const u=i[0],f=i[1],T=Math.round(f.x-u.x),b=Math.round(f.y-u.y),y=Math.max(Math.abs(T),Math.abs(b));a=o(T>0?u.x+y/2:u.x-y/2,b>0?u.y+y/2:u.y-y/2),n=o(Math.abs(T)>Math.abs(b)?a.x-y/2:a.x,Math.abs(T)>Math.abs(b)?a.y:a.y-y/2)}const c=e.localToMap(a),l=e.localToMap(n);if(c==null||l==null)return null;e.doUnnormalization&&ge([[c,l]],e.spatialReference);const p=w(c,e.spatialReference),h=w(l,e.spatialReference),m=Re(e.spatialReference);let g=0;if(B(e.spatialReference))g=m*we(p,h);else{const u=a.x-n.x,f=a.y-n.y;g=m*Math.sqrt(u*u+f*f)*1}const F=new $e({center:p,radius:g,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:L(F.rings,F.spatialReference,!1),center:p,edge:h}}function Ae(t,e,s){const r=e.mapToLocalMultiple(t),i=r[0],a=r[1],n=Math.round(a.x-i.x),c=Math.round(a.y-i.y),l=o(s?i.x:i.x+n/2,s?i.y:i.y+c/2),p=s?n:n/2,h=s?c:c/2,m=60,g=[],F=2*Math.PI/m;function u(R){const q=Math.cos(R),Q=Math.sin(R);return o(p*q+l.x,h*Q+l.y)}for(let R=0;R<m;R++)g.push(u(R*F));g.push(g[0]);const{spatialReference:f,doUnnormalization:T}=e,b=L([g.map(R=>e.localToMap(R)).filter(I)],f,T,!1),y=e.localToMap(u(Math.PI/2)),_=e.localToMap(u(0)),Z=e.localToMap(u(-Math.PI/2)),j=e.localToMap(u(Math.PI));return{geometry:b,midpoints:y!=null&&_!=null&&Z!=null&&j!=null?{top:w(y,f),right:w(_,f),bottom:w(Z,f),left:w(j,f)}:null}}export{Ze as R,L as T,Ne as U,Ae as a,He as b,je as j,Oe as k,_e as v};

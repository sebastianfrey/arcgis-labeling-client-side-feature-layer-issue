import{kl as p,eF as D,aF as U,km as z,kn as R}from"./index-C_bK48d2.js";const L=15.5,S=4,P=64,K=1024,Q={outlineWidth:.75,referenceWidth:.75,cap:p.CIMSolidStroke.capstyle,join:p.CIMSolidStroke.joinstyle,miterLimit:p.CIMSolidStroke.miterlimit};function $(o,s,r=0){const e=D(o,0,G);for(let a=0;a<4;a++)s[r+a]=Math.floor(256*W(e*q[a]))}function b(o,s=0){let r=0;for(let e=0;e<4;e++)r+=o[s+e]*E[e];return r}const q=[1,256,65536,16777216],E=[1/256,1/65536,1/16777216,1/4294967296],G=b(new Uint8ClampedArray([255,255,255,255]));b(new Uint8ClampedArray([255,255,255,0]));function W(o){return o-Math.floor(o)}const I=()=>U.getLogger("esri.symbols.cim.rasterizingUtils"),j=32,B=o=>o==="vertical"||o==="horizontal"||o==="cross"||o==="esriSFSCross"||o==="esriSFSVertical"||o==="esriSFSHorizontal";function X(o,s,r){const e=s.style,a=z(Math.ceil(r)),t=B(e)?8*a:16*a,n=2*a;o.width=t,o.height=t;const i=o.getContext("2d");i.strokeStyle="#ffffff",i.lineWidth=a,i.beginPath(),e!=="vertical"&&e!=="cross"&&e!=="esriSFSCross"&&e!=="esriSFSVertical"||(i.moveTo(t/2,-n),i.lineTo(t/2,t+n)),e!=="horizontal"&&e!=="cross"&&e!=="esriSFSCross"&&e!=="esriSFSHorizontal"||(i.moveTo(-n,t/2),i.lineTo(t+n,t/2)),e!=="backward-diagonal"&&e!=="diagonal-cross"&&e!=="esriSFSDiagonalCross"&&e!=="esriSFSBackwardDiagonal"||(i.moveTo(-n,-n),i.lineTo(t+n,t+n),i.moveTo(t-n,-n),i.lineTo(t+n,n),i.moveTo(-n,t-n),i.lineTo(n,t+n)),e!=="forward-diagonal"&&e!=="diagonal-cross"&&e!=="esriSFSForwardDiagonal"&&e!=="esriSFSDiagonalCross"||(i.moveTo(t+n,-n),i.lineTo(-n,t+n),i.moveTo(n,-n),i.lineTo(-n,n),i.moveTo(t+n,t-n),i.lineTo(t-n,t+n)),i.stroke();const h=i.getImageData(0,0,o.width,o.height),l=new Uint8Array(h.data);let f;for(let c=0;c<l.length;c+=4)f=l[c+3]/255,l[c]=l[c]*f,l[c+1]=l[c+1]*f,l[c+2]=l[c+2]*f;return[l,o.width,o.height,a]}function Y(o){o.length%2==1&&(o=[...o,...o]);const s=o.reduce((c,u)=>c+u,0),r=Math.round(s*S),e=1,a=new Float32Array(r*e);let t=0,n=0,i=.5,h=!0;for(const c of o){for(t=n,n+=c*S;i<=n;){const u=i-.5,m=Math.min(Math.abs(i-t),Math.abs(i-n));a[u]=h?-m:m,i++}h=!h}const l=a.length,f=new Uint8Array(4*l);for(let c=0;c<l;++c){const u=a[c]/S;$(u/P*.5+.5,f,4*c)}return[f,r,e]}function Z(o,s){o==null&&(o=[]);const r=s==="Butt",e=s==="Square",a=!r&&!e;o.length%2==1&&(o=[...o,...o]);const t=L,n=2*t;let i=0;for(const d of o)i+=d;const h=Math.round(i*t),l=new Float32Array(h*n),f=.5*t;let c=0,u=0,m=.5,y=!0;for(const d of o){for(c=u,u+=d*t;m<=u;){let C=.5;for(;C<n;){const A=(C-.5)*h+m-.5,g=a?(C-t)*(C-t):Math.abs(C-t);l[A]=y?r?Math.max(Math.max(c+f-m,g),Math.max(m-u+f,g)):g:a?Math.min((m-c)*(m-c)+g,(m-u)*(m-u)+g):e?Math.min(Math.max(m-c,g),Math.max(u-m,g)):Math.min(Math.max(m-c+f,g),Math.max(u+f-m,g)),C++}m++}y=!y}const T=l.length,v=new Uint8Array(4*T);for(let d=0;d<T;++d){const C=(a?Math.sqrt(l[d]):l[d])/t;$(C,v,4*d)}return[v,h,n]}function _(o,s){const{colorRamp:r,gradientType:e}=s,a=r.type==="CIMFixedColorRamp",t=s.interval||p.CIMGradientFill.interval;let n=w(r);return a&&(n=k(n,t)),e==="Discrete"||a?V(o,n,t):H(o,n)}let x;function oo(o,s){const{colorRamp:r,gradientType:e}=s,a=w(r),t=r.type==="CIMFixedColorRamp";if(e==="Continuous"&&!t)return M(o,a);const n=s.interval??p.CIMGradientFill.interval;if(t)return M(o,k(a,n));const i=[];x??(x=document.createElement("canvas")),F(x,a,n,1,0);const h=x.getContext("2d").getImageData(0,0,n,1).data;for(let l=0,f=0;l<n;l++,f=4*l){const c=[h[f+0],h[f+1],h[f+2],h[f+3]];i.push({offset:l/n,color:c}),i.push({offset:(l+1)/n,color:c})}return M(o,i)}function w(o){const s=[];switch(o.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{o.type==="CIMPolarContinuousColorRamp"&&I().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const r=o;s.push({offset:0,color:[r.fromColor[0],r.fromColor[1],r.fromColor[2],r.fromColor[3]/255]}),s.push({offset:1,color:[r.toColor[0],r.toColor[1],r.toColor[2],r.toColor[3]/255]});break}case"CIMFixedColorRamp":{const r=o,e=1/(r.colors.length-1);let a=0;for(const t of r.colors)s.push({offset:a,color:[t[0],t[1],t[2],t[3]/255]}),a+=e;break}case"CIMMultipartColorRamp":{const r=o,e=r.weights.reduce((t,n)=>t+n,0);let a=0;for(let t=0;t<r.colorRamps.length;t++){const n=r.colorRamps[t],i=r.weights[t],h=w(n);for(const l of h)s.push({offset:(a+l.offset*i)/e,color:l.color});a+=i}break}default:I().error(`Color ramp "${o.type}" currently unsupported.`)}return s}function k(o,s){const r=[],e=(o.length-1)/(s-1);for(let a=0;a<s;a++){const t=o[Math.round(a*e)].color;r.push({offset:a/s,color:t}),r.push({offset:(a+1)/s,color:t})}return r}function H(o,s){return F(o,s,j,1,R),N(o)}function V(o,s,r){return F(o,s,r,1,R),N(o)}function M(o,s,r=0){for(const{offset:e,color:a}of s)o.addColorStop(Math.min(Math.max(e,r),1-r),`rgba(${a[0]}, ${a[1]}, ${a[2]}, ${a[3]})`)}function F(o,s,r,e,a){const t=r+2*a;o.width=t,o.height=e;const n=(a+1)/t,i=o.getContext("2d",{willReadFrequently:!0});if(s.length>0){const h=i.createLinearGradient(0,0,t,e);M(h,s,n),i.fillStyle=h}else i.fillStyle="rgba(128, 128, 128, 1)";i.fillRect(0,0,t,e)}function N(o){const{width:s,height:r}=o,e=o.getContext("2d").getImageData(0,0,s,r),a=new Uint8Array(e.data);for(let t=0;t<a.length;t+=4){const n=a[t+3]/255;a[t]*=n,a[t+1]*=n,a[t+2]*=n}return[a,s,r]}function O(o){var a,t,n,i;const s=((t=(a=o[0])==null?void 0:a[0])==null?void 0:t[0])??0,r=((i=(n=o[0])==null?void 0:n[0])==null?void 0:i[1])??0,e={ymin:r,xmin:s,ymax:r,xmax:s,width:0,height:0};for(let h=0;h<o.length;h++){const l=o[h];for(let f=0;f<l.length;f++){const c=l[f][0],u=l[f][1];c<e.xmin&&(e.xmin=c),c>e.xmax&&(e.xmax=c),u<e.ymin&&(e.ymin=u),u>e.ymax&&(e.ymax=u)}}return e.width=Math.abs(e.xmax-e.xmin),e.height=Math.abs(e.ymax-e.ymin),e}function to(o,s){const r=O(o),e=r.width===0?1:r.width,a=r.height===0?1:r.height,t=[];for(let n=0;n<o.length;n++){const i=o[n],h=[];for(let l=0;l<i.length;l++){let f=Math.round(i[l][0]-r.xmin),c=Math.round(i[l][1]-r.ymin);if(f=s.xmin+f*s.width/e,c=s.ymin+c*s.height/a,isNaN(f)||isNaN(c))throw new Error("Scaled shape has NaN values");h.push([f,c])}t.push(h)}return t}function eo(o,s,r){const e=[];for(let a=0;a<o.length;a++){const t=o[a],n=[];for(let i=0;i<t.length;i++){const h=t[i][0]+s,l=t[i][1]+r;if(isNaN(h)||isNaN(l))throw new Error("Scaled shape has NaN values");n.push([h,l])}e.push(n)}return e}export{eo as R,to as T,P as a,X as f,_ as g,S as i,Q as l,Y as m,$ as o,oo as p,K as r,Z as u};

import{i1 as v,du as b,i2 as P,i3 as N,h as T,dE as d,dF as j,dG as q,dH as F,i4 as Z,i5 as k,bN as A,dC as B}from"./index-C_bK48d2.js";import{c as D}from"./GraphicManipulator-Bi7jhnCD.js";function R(n,i,e,t){if(n.type==="point")return n.x+=i,n.y+=e,n.hasZ&&t!=null&&(n.z+=t),n;if(n.type==="multipoint"){const r=n.points;for(let o=0;o<r.length;o++)r[o]=U(r[o],i,e,t);return n}if(n.type==="extent")return n.xmin+=i,n.xmax+=i,n.ymin+=e,n.ymax+=e,n;const s=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,u=B(n);for(let r=0;r<s.length;r++){const o=s[r];for(let m=0;m<o.length;m++)o[m]=J(o[m],i,e,t)}return"paths"in n?u?n.curvePaths=s:n.paths=s:u?n.curveRings=s:n.rings=s,n}function Q(n,i,e,t,s){const u=n.clone();if(s){const{resolution:r}=t;R(u,i*r,-e*r)}else{const{dxMap:r,dyMap:o}=I(i,e,t);R(u,r,o)}return u}function I(n,i,e){const t=e.state.inverseTransform;return{dxMap:t[0]*n+t[2]*i,dyMap:t[1]*n+t[3]*i}}function U(n,i,e,t){return w(n,n[0]+i,n[1]+e,n[2]!=null&&t!=null?n[2]+t:void 0)}function J(n,i,e,t){const s=U(d(n),i,e,t);if(j(n))return s;if(q(n)){const[,o,m]=n.b;return{b:[s,[o[0]+i,o[1]+e],[m[0]+i,m[1]+e]]}}if(F(n)){const[,o]=n.c;return{c:[s,[o[0]+i,o[1]+e]]}}const[,u,...r]=n.a;return{a:[s,[u[0]+i,u[1]+e],...r]}}function S(n,i,e,t){if(n.type==="point"){const{x:c,y:f}=n,y=t?t[0]:c,l=t?t[1]:f,x=n.clone(),p=(c-y)*i+y,a=(f-l)*e+l;return x.x=p,x.y=a,x}if(n.type==="extent"){const{xmin:c,xmax:f,ymin:y,ymax:l}=n,x=t?t[0]:(c+f)/2,p=t?t[1]:(l+y)/2,a=n.clone();if(a.xmin=(c-x)*i+x,a.ymax=(l-p)*e+p,a.xmax=(f-x)*i+x,a.ymin=(y-p)*e+p,a.xmin>a.xmax){const h=a.xmin,M=a.xmax;a.xmin=M,a.xmax=h}if(a.ymin>a.ymax){const h=a.ymin,M=a.ymax;a.ymin=M,a.ymax=h}return a}let s=null;if(!t){s=v(n);const c=b(),f=P(c,s);if(!f)return n.clone();const[y,l,x,p]=f;t=[(y+x)/2,(l+p)/2]}const[u,r]=t;if(n.type==="multipoint"){const c=n.clone(),f=c.points;for(let y=0;y<f.length;y++){const l=f[y],[x,p]=l,a=(x-u)*i+u,h=(p-r)*e+r;f[y]=w(l,a,h,void 0)}return c.points=f,c}const o=n.clone();s??(s=v(n));const m=o.type==="polygon",g=m?o.curveRings??o.rings:o.curvePaths??o.paths;if(!t){const c=b(),f=P(c,g,!1,!1);if(!f)return o;t=N(f)}for(const c of g){let f=null;const y=m&&c.length>0&&T(d(c[0]),d(c.at(-1)));for(let l=0;l<c.length;l++){const x=c[l];c[l]=K(x,i,e,u,r,f),f=x}y&&(c[0]=[...d(c.at(-1))])}return o}function z(n,i,e,t,s){const[u,r,...o]=n;return[(u-t)*i+t,(r-s)*e+s,...o]}function K(n,i,e,t,s,u){if(j(n))return z(n,i,e,t,s);if(q(n)){const[C,E,G]=n.b.map(H=>z(H,i,e,t,s));return{b:[C,E,G]}}if(!u)return n;const r=d(u),o=F(n)?Z(r,n):n,[m,g,c,f,y,l,x]=o.a,p=y??0,a=l??Math.hypot(m[0]-g[0],m[1]-g[1]),h=x??1,M=D(t,s,1,0,0,1,i,e);return k(r,{a:[[...m],[...g],c,f,p,a,h]},M)}function V(n,i,e,t,s,u){const r=Math.sqrt((e-n)*(e-n)+(t-i)*(t-i));return Math.sqrt((s-n)*(s-n)+(u-i)*(u-i))/r}function W(n,i,e,t=!1){const s=Math.atan2(i.y-e.y,i.x-e.x)-Math.atan2(n.y-e.y,n.x-e.x),u=Math.atan2(Math.sin(s),Math.cos(s));return t?u:A(u)}function w(n,i,e,t){const s=[i,e];return n.length>2&&s.push(t??n[2]),n.length>3&&s.push(n[3]),s}export{S as M,V as U,W as b,I as h,Q as x};

import{a as m,m as C}from"./Point2D-CHGoJJR2.js";import"./Envelope2D-K-BIX8ba.js";import{h as V,g as P,s as h}from"./ProjectionTransformation-yTMc8p-1.js";import{ax as Z,fM as v,aM as p,dl as w,dk as R}from"./index-C_bK48d2.js";import{fromGeometryToGXGeometry as g,fromSpatialReference as d,toGeometry as y}from"./jsonConverter-E47-BQ_b.js";import"./Transformation2D-CsY48lRi.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./OperatorDefinitions-DP7_WWTp.js";const a="_gxVersion",x=2,M=1;function k(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function B(t){switch(t.type){case"point":return G(t);case"multipoint":return z(t);case"polyline":return Y(t);case"polygon":return X(t);case"extent":return E(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function E(t){if(!t.getCacheValue(a)){const e=new V;e.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&e.setInterval(x,0,t.mmin,t.mmax),t.hasZ&&e.setInterval(M,0,t.zmin,t.zmax),t.setCacheValue(a,e)}return t.getCacheValue(a)}function z(t){if(!t.getCacheValue(a)){const e=new P,n=new h,s=t.points,r=t.hasM,o=t.hasZ,i=o?3:2;for(let u=0,l=s.length;u<l;u++){const c=s[u];n.setXYCoords(c[0],c[1]),o&&n.setZ(c[2]??0),r&&n.setM(c[i]??NaN),e.add(n)}t.setCacheValue(a,e)}return t.getCacheValue(a)}function G(t){if(!t.getCacheValue(a)){const e=new h;e.setXYCoords(t.x,t.y),t.hasM&&e.setM(t.m),t.hasZ&&e.setZ(t.z),t.setCacheValue(a,e)}return t.getCacheValue(a)}function X(t){if(!t.getCacheValue(a)){const{curveRings:e,hasM:n,hasZ:s,rings:r}=t,o=g({curveRings:e,hasM:n,hasZ:s,rings:r});t.setCacheValue(a,o)}return t.getCacheValue(a)}function Y(t){if(!t.getCacheValue(a)){const{curvePaths:e,hasM:n,hasZ:s,paths:r}=t,o=g({curvePaths:e,hasM:n,hasZ:s,paths:r});t.setCacheValue(a,o)}return t.getCacheValue(a)}function b(t){return d(t)}function F(t,e){if(t)switch(t.getGeometryType()){case m.enumPoint:return N(t,e);case m.enumEnvelope:return S(t,e);case m.enumMultiPoint:return I(t,e);case m.enumPolyline:return D(t,e);case m.enumPolygon:return $(t,e)}return null}function S(t,e){if(t.isEmpty())return null;const n=new Z({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:e}),s=t.getDescription();if(s.hasM()){const r=t.queryInterval(x,0);n.mmin=r.vmin,n.mmax=r.vmax}if(s.hasZ()){const r=t.queryInterval(M,0);n.zmin=r.vmin,n.zmax=r.vmax}return n.setCacheValue(a,t),n}function I(t,e){if(t.isEmpty())return null;const n=t.getDescription(),s=n.hasM(),r=n.hasZ(),o=[],i=new h;for(let l=0,c=t.getPointCount();l<c;l++){t.getPointByVal(l,i);const f=[i.getX(),i.getY()];r&&f.push(i.getZ()),s&&f.push(i.getM()),o.push(f)}const u=new v({hasM:s,hasZ:r,points:o,spatialReference:e});return u.setCacheValue(a,t),u}function N(t,e){if(t instanceof C)return new p({x:t.x,y:t.y,spatialReference:e});if(t.isEmpty())return null;const n=new p({x:t.getX(),y:t.getY(),spatialReference:e}),s=t.getDescription();return s.hasM()&&(n.m=t.getM()),s.hasZ()&&(n.z=t.getZ()),n.setCacheValue(a,t),n}function $(t,e){if(t.isEmpty())return null;const n=w.fromJSON({spatialReference:e,...y(t,null)});return n.setCacheValue(a,t),n}function D(t,e){if(t.isEmpty())return null;const n=R.fromJSON({spatialReference:e,...y(t,null)});return n.setCacheValue(a,t),n}export{E as fromExtent,B as fromGeometry,z as fromMultipoint,G as fromPoint,X as fromPolygon,Y as fromPolyline,b as fromSpatialReference,k as getSpatialReference,S as toExtent,F as toGeometry,I as toMultipoint,N as toPoint,$ as toPolygon,D as toPolyline};

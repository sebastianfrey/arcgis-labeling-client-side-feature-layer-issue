import{fB as A,b_ as nt,b5 as m,gN as rt,b3 as L,gn as y,go as P,gO as H}from"./index-C_bK48d2.js";import{d as R}from"./frustum-BtvbAxAw.js";import{k as J}from"./ray-DFDOQn-4.js";import{E}from"./sphere-Dx28BAGo.js";import{i as K}from"./BufferView-CruTDoyp.js";class Q{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new c,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),c.clearPool(),$[0]=null,N.prune(),T.prune()}add(t){const e=Array.from(t);this._grow(e);const n=c.acquire();for(const r of e)++this._objectCount,this._isDegenerate(r)?this._degenerateObjects.add(r):(n.init(this._root),this._add(r,n));c.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=c.acquire();for(const r of t){const a=e??this.objectToBoundingSphere(r);w(a.radius)?(n.init(this._root),it(r,a,n)):this._degenerateObjects.delete(r)}c.release(n),this._shrink()}update(t,e){if(!w(e.radius)&&this._isDegenerate(t))return;const n=ct(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const r=J(t,e);M(this._root,a=>{if(!st(r,a))return!1;const s=a.node;return s.terminals.forAll(h=>{this._intersectsObject(r,h)&&n(h)}),s.residents!==null&&s.residents.forAll(h=>{this._intersectsObject(r,h)&&n(h)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,r){const a=J(t,e);M(this._root,s=>{if(!at(a,s,r))return!1;const h=s.node;return h.terminals.forAll(o=>{this._intersectsObjectWithOffset(a,o,r)&&n(o)}),h.residents!==null&&h.residents.forAll(o=>{this._intersectsObjectWithOffset(a,o,r)&&n(o)}),!0})}forEach(t){M(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,r=()=>!0,a=1/0){let s=1/0,h=1/0,o=null;const u=q(t,e),f=d=>{if(--a,!r(d))return;const _=this.objectToBoundingSphere(d);if(!R(n,_))return;const S=z(t,e,_.center),B=S-_.radius,l=S+_.radius;B<s&&(s=B,h=l,o=d)};return W(this._root,d=>{if(a<=0||!R(n,d.bounds)||(y(g,u,d.halfSize),P(g,g,d.bounds.center),z(t,e,g)>h))return!1;const _=d.node;return _.terminals.forAll(S=>f(S)),_.residents!==null&&_.residents.forAll(S=>f(S)),!0},t,e),o}forEachInDepthRange(t,e,n,r,a,s,h){let o=-1/0,u=1/0;const f={setRange:l=>{n===1?(o=Math.max(o,l.near),u=Math.min(u,l.far)):(o=Math.max(o,-l.far),u=Math.min(u,-l.near))}};f.setRange(r);const d=z(e,n,t),_=q(e,n),S=q(e,-n),B=l=>{if(!h(l))return;const O=this.objectToBoundingSphere(l),D=z(e,n,O.center)-d,tt=D-O.radius,et=D+O.radius;tt>u||et<o||!R(s,O)||a(l,f)};W(this._root,l=>{if(!R(s,l.bounds)||(y(g,_,l.halfSize),P(g,g,l.bounds.center),z(e,n,g)-d>u)||(y(g,S,l.halfSize),P(g,g,l.bounds.center),z(e,n,g)-d<o))return!1;const O=l.node;return O.terminals.forAll(D=>B(D)),O.residents!==null&&O.residents.forAll(D=>B(D)),!0},e,n)}forEachNode(t){M(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=e.radius,r=e.center,a=o=>{const u=this.objectToBoundingSphere(o),f=u.radius,d=n+f;return!(H(u.center,r)-d*d<=0)||t(o)};let s=!0;const h=o=>{s&&(s=a(o))};M(this._root,o=>{const u=o.bounds.radius,f=n+u;if(H(o.bounds.center,r)-f*f>0)return!1;const d=o.node;return d.terminals.forAll(h),s&&d.residents!==null&&d.residents.forAll(h),s}),s&&this.forEachDegenerateObject(h)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n.radius>0)||n.intersectRay(t)}_intersectsObjectWithOffset(t,e,n){const r=this.objectToBoundingSphere(e);return!(r.radius>0)||n.applyToBoundingSphere(r).intersectRay(t)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const r=c.acquire().init(t);this._add(e.at(n),r),c.release(r)}}_grow(t){if(V(t,e=>this.objectToBoundingSphere(e),x),w(x.radius)&&!this._fitsInsideTree(x))if(X(this._root.node))this._root.bounds.copy(x),this._root.halfSize=1.25*this._root.bounds.radius,this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(x);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(x,e):this._growRootAsSubNode(e),c.release(e)}}_rebuildTree(t,e){C.center=e.bounds.center,C.radius=e.halfSize,V([t,C],r=>r,I);const n=c.acquire().init(this._root);this._root.initFrom(null,I,I.radius),this._root.increaseHalfSize(1.25),M(n,r=>(this.add(r.node.terminals.data),r.node.residents!==null&&this.add(r.node.residents.data),!0)),c.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return M(this._root,r=>(n=Math.max(n,r.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t.radius,n=t.center;let r=-1/0;const a=this._root.bounds.center,s=this._root.halfSize;for(let o=0;o<3;o++){const u=a[o]-s-(n[o]-e),f=n[o]+e-(a[o]+s),d=Math.max(0,Math.ceil(u/(2*s))),_=Math.max(0,Math.ceil(f/(2*s)))+1,S=2**Math.ceil(Math.log(d+_)*Math.LOG2E);r=Math.max(r,S),v[o].min=d,v[o].max=_}for(let o=0;o<3;o++){let u=v[o].min,f=v[o].max;const d=(r-(u+f))/2;u+=Math.ceil(d),f+=Math.floor(d);const _=a[o]-s-u*s*2;k.center[o]=_+(f+u)*s}const h=r*s;return k.radius=h*Z,c.acquire().initFrom(null,k,h,0)}_growRootAsSubNode(t){const e=this._root.node;x.center=this._root.bounds.center,x.radius=this._root.halfSize,this._root.init(t),t.advanceTo(x,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,r=0;for(;r<e.length&&t==null;)n=r++,t=e[n];for(;r<e.length;)if(e[r++])return-1;return n}_isDegenerate(t){return!w(this.objectToBoundingSphere(t).radius)}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t.radius<=n&&t.center[0]>=e.center[0]-n&&t.center[0]<=e.center[0]+n&&t.center[1]>=e.center[1]-n&&t.center[1]<=e.center[1]+n&&t.center[2]>=e.center[2]-n&&t.center[2]<=e.center[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,r=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:r}}}_nodeToJSON(t){var a,s;const e=t.children.map(h=>h?this._nodeToJSON(h):null),n=(a=t.residents)==null?void 0:a.map(h=>this.objectToBoundingSphere(h)),r=(s=t.terminals)==null?void 0:s.map(h=>this.objectToBoundingSphere(h));return{children:e,residents:n,terminals:r}}static fromJSON(t){const e=new Q(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}}const j=class j{constructor(){this.bounds=new E,this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,r=this.depth){return this.node=t??j.createEmptyNode(),e&&this.bounds.copy(e),this.halfSize=n,this.depth=r,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds.radius=this.halfSize*Z}advance(t){let e=this.node.children[t];e||(e=j.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=Y[t];return this.bounds.center[0]+=n[0]*this.halfSize,this.bounds.center[1]+=n[1]*this.halfSize,this.bounds.center[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e==null||e(this,-1),!0;if(this.isLeaf()){if(!n)return e==null||e(this,-1),!1;this.node.residents=null}const r=this._childIndex(t);e==null||e(this,r),this.advance(r)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t.radius>this.halfSize/2}_childIndex(t){const e=this.bounds.center;return(e[0]<t.center[0]?1:0)+(e[1]<t.center[1]?2:0)+(e[2]<t.center[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new A({shrink:!0}),residents:new A({shrink:!0})}}static acquire(){return j._pool.acquire()}static release(t){j._pool.release(t)}static clearPool(){j._pool.prune()}};j._pool=new nt(()=>new j);let c=j;function M(i,t){let e=c.acquire().init(i);const n=[e];for(;n.length!==0;){if(e=n.pop(),t(e)&&!e.isLeaf())for(let r=0;r<e.node.children.length;r++)e.node.children[r]&&n.push(c.acquire().init(e).advance(r));c.release(e)}}function W(i,t,e,n=1){let r=c.acquire().init(i);const a=[r];for(ut(e,n,U);a.length!==0;){if(r=a.pop(),t(r)&&!r.isLeaf())for(let s=7;s>=0;--s){const h=U[s];r.node.children[h]&&a.push(c.acquire().init(r).advance(h))}c.release(r)}}function it(i,t,e){N.clear();const n=e.advanceTo(t,(r,a)=>{N.push(r.node),N.push(a)})?e.node.terminals:e.node.residents;if(n.removeUnordered(i),n.length===0)for(let r=N.length-2;r>=0&&ot(N.data[r],N.data[r+1]);r-=2);}function ot(i,t){return t>=0&&(i.children[t]=null),!!X(i)&&(i.residents===null&&(i.residents=new A({shrink:!0})),!0)}function st(i,t){return F(t.bounds.center,2*-t.halfSize,b),F(t.bounds.center,2*t.halfSize,p),K(i.origin,i.direction,b,p)}function at(i,t,e){return F(t.bounds.center,2*-t.halfSize,b),F(t.bounds.center,2*t.halfSize,p),e.applyToMinMax(b,p),K(i.origin,i.direction,b,p)}function X(i){if(i.terminals.length!==0)return!1;if(i.residents!==null)return i.residents.length===0;for(let t=0;t<i.children.length;t++)if(i.children[t])return!1;return!0}function ht(i,t){i[0]=Math.min(i[0],t.center[0]-t.radius),i[1]=Math.min(i[1],t.center[1]-t.radius),i[2]=Math.min(i[2],t.center[2]-t.radius)}function dt(i,t){i[0]=Math.max(i[0],t.center[0]+t.radius),i[1]=Math.max(i[1],t.center[1]+t.radius),i[2]=Math.max(i[2],t.center[2]+t.radius)}function F(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function V(i,t,e){b[0]=1/0,b[1]=1/0,b[2]=1/0,p[0]=-1/0,p[1]=-1/0,p[2]=-1/0;for(const n of i){const r=t(n);w(r.radius)&&(ht(b,r),dt(p,r))}rt(e.center,b,p,.5),e.radius=Math.max(p[0]-b[0],p[1]-b[1],p[2]-b[2])/2}function ut(i,t,e){if(!T.length)for(let n=0;n<8;++n)T.push({index:0,distance:0});for(let n=0;n<8;++n){const r=Y[n];T.data[n].index=n,T.data[n].distance=z(i,t,r)}T.sort((n,r)=>n.distance-r.distance);for(let n=0;n<8;++n)e[n]=T.data[n].index}function q(i,t){let e,n=1/0;for(let r=0;r<8;++r){const a=z(i,t,G[r]);a<n&&(n=a,e=G[r])}return e}function z(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function w(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}const Y=[m(-1,-1,-1),m(1,-1,-1),m(-1,1,-1),m(1,1,-1),m(-1,-1,1),m(1,-1,1),m(-1,1,1),m(1,1,1)],G=[m(-1,-1,-1),m(-1,-1,1),m(-1,1,-1),m(-1,1,1),m(1,-1,-1),m(1,-1,1),m(1,1,-1),m(1,1,1)],Z=Math.sqrt(3),$=[null];function ct(i){return $[0]=i,$}const k=new E,g=L(),b=L(),p=L(),N=new A,x=new E,C=new E,I=new E,v=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],T=new A,U=[0,0,0,0,0,0,0,0];export{Q as l};
